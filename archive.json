{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-01-30T01:09:23.122637+00:00",
  "repo": "ietf-wg-masque/draft-ietf-masque-connect-udp",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "extension",
      "description": "This could done by an extension",
      "color": "0052cc"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU2ODc2OTQ1NTE=",
      "title": "CONNECT-UDP and multiple intermediaries",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/1",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/21#issue-601716642)\r\n\r\n> Note that when multiple proxies are involved in a CONNECT-UDP request, all the HTTP connections along the path need to be using HTTP/3 [H3] or later in order for UDP payloads to be sent over QUIC DATAGRAM frames.\r\n\r\nHow is this true? The first proxy should convert the stream of encapsulated UDP datagrams into actual UDP datagrams. That means that the second proxy won't see these as part of the connection.\r\n\r\nThis is only an issue if the proxy wants to pass the DATAGRAM frames on to the next proxy. But that's not what is being asked of it, if it does that, it does so on its own recognizance. (I should add: if it chooses to forward to a next hop that uses h2, then it can take the DATAGRAM frames and stuff them into the request stream.)",
      "createdAt": "2020-08-28T04:03:10Z",
      "updatedAt": "2020-12-13T04:42:07Z",
      "closedAt": "2020-12-13T04:42:07Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply by me on 2020-04-17:\r\n\r\nIt's definitely possible for a chain of proxies to use heterogeneous encodings for their UDP packets, by which I mean if the topology is `Client - ProxyA - ProxyB - Destination` then we could build this so that `Client - ProxyA` uses DATAGRAM frames whereas `ProxyA - ProxyB` uses the stream encoding with HTTP/2.\r\n\r\nI don't think the benefits outweigh the added complexity, so the current design is all-or-nothing: if all legs supports H3-DATAGRAM then it can be used, otherwise fallback to the stream encoding.",
          "createdAt": "2020-08-28T04:03:51Z",
          "updatedAt": "2020-08-28T04:03:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply by @martinthomson on 2020-04-19:\r\n\r\nI'm not really clear on how you think that might work. If Client and Proxy A negotiate the use of DATAGRAM, does this depend on Proxy A verifying first that Proxy B also supports DATAGRAM? How do you ensure that the identifiers are comprehensible to all parties?",
          "createdAt": "2020-08-28T04:04:13Z",
          "updatedAt": "2020-08-28T04:04:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:07Z",
          "updatedAt": "2020-12-13T04:42:07Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU2ODc2OTUzMjM=",
      "title": "CONNECT-UDP request body",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/2",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/22):\r\n\r\n>    A payload within a CONNECT-UDP request message has no defined semantics; a CONNECT-UDP request with a non-empty payload is malformed.\r\n\r\nI think that this text is out of sync with the rest of the doc.  The payload is used to carry UDP packets, even when you use DATAGRAM frames.",
      "createdAt": "2020-08-28T04:05:37Z",
      "updatedAt": "2020-12-13T04:42:09Z",
      "closedAt": "2020-12-13T04:42:08Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Reply from me on 2020-04-17:\r\n\r\nI think this is just a question of semantics. CONNECT takes over the stream, and therefore the contents of that stream are not considered to be the payload of the HTTP response.\r\n\r\nFrom [RFC 7231 s4.3.6](https://tools.ietf.org/html/rfc7231#section-4.3.6):\r\n>   A payload within a CONNECT request message has no defined semantics;\r\n>   sending a payload body on a CONNECT request might cause some existing\r\n>   implementations to reject the request.",
          "createdAt": "2020-08-28T04:06:03Z",
          "updatedAt": "2020-08-28T04:06:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:08Z",
          "updatedAt": "2020-12-13T04:42:08Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2ODc2OTU5NzU=",
      "title": "Datagram-Flow-Id is hop-by-hop",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/3",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue reported by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/23):\r\n\r\nThat is *probably* OK for something with CONNECT-like semantics, but we did explicitly choose to disable hop-by-hop fields in HTTP/2.",
      "createdAt": "2020-08-28T04:07:34Z",
      "updatedAt": "2020-12-13T04:42:10Z",
      "closedAt": "2020-12-13T04:42:10Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from @martinthomson on 2020-04-16:\r\n\r\nI just realized that, because this is a new method and will be treated as such by intermediaries that don't understand it, they will pass Datagram-Flow-Id along. That is very much a bad thing as the server on the next hop might have negotiated H3_DATAGRAM with the intermediary for other reasons. If the next hop understands the setting, it might send responses in datagrams that will then be dropped by the intermediary (because it doesn't understand Datagram-Flow-Id).\r\n\r\nThat is, on a chain of entities from client A, intermediary B, and intermediary C, if all of them support H3_DATAGRAM, but B does not support Datagram-Flow-Id or CONNECT-UDP, this ultimately results in packets being sent on the request stream for a while, then DATAGRAM frames being sent toward the intermediary and being dropped.",
          "createdAt": "2020-08-28T04:07:56Z",
          "updatedAt": "2020-08-28T04:07:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nRegarding your first comment, I agree that this is somewhat of a hop-by-hop field. Do you have a proposal that achieves the same result without using a hop-by-hop field?\r\n\r\nRegarding your second comment, it's not possible for intermediaries to not understand this and still pass it along. If the intermediary doesn't know about this spec it'll respond with status code 405 \"Method Not Allowed\" instead of forwarding it.",
          "createdAt": "2020-08-28T04:08:11Z",
          "updatedAt": "2020-08-28T04:08:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from @martinthomson on 2020-04-19:\r\n\r\nProxies aren't required to understand all methods, so why would it send a 405? I mean, some might because they want to police what methods they pass, but they are not required to do so.",
          "createdAt": "2020-08-28T04:08:26Z",
          "updatedAt": "2020-08-28T04:08:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-07-24:\r\n\r\nSorry, I should have said 501 \"Not Implemented\", not 405.",
          "createdAt": "2020-08-28T04:08:43Z",
          "updatedAt": "2020-08-28T04:08:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:10Z",
          "updatedAt": "2020-12-13T04:42:10Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2ODc2OTY3OTg=",
      "title": "Flow duration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/4",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/24):\r\n\r\nThe CONNECT-UDP proxy has to act a little like a NAT when it forwards UDP. It has to assign a source IP and port. Those probably need to be dedicated to the flow for its lifetime. However, UDP lacks the clear signals of TCP about connection termination, so we need a clear definition of what lifetime is.\r\n\r\nIt is perhaps reasonable to tie the lifetime of the allocation to the existence of the stream, but then the connection from the client might drop mid-flow; how long does the proxy need to avoid reusing that address?\r\n\r\nThe proxy might also decide that idleness is cause for dropping bindings. The client needs to know this because it will need to make new tunnels to continue communication if it goes idle for too long.",
      "createdAt": "2020-08-28T04:10:04Z",
      "updatedAt": "2020-12-13T04:42:12Z",
      "closedAt": "2020-12-13T04:42:11Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nThe intent was to have the lifetime of the UDP socket be tied to the existence of the CONNECT-UDP stream. But I agree that we should add text indicating that a server MAY want to garbage collect these after idle periods, and in that case it MUST close the corresponding stream to inform the client.",
          "createdAt": "2020-08-28T04:10:18Z",
          "updatedAt": "2020-08-28T04:10:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "An interesting extension: retain the binding for N seconds after the connection to the proxy drops and allow the client to rebind to that.  That allows for session continuity across transient connection failures for protocols that aren't QUIC (which are less vulnerable to that).",
          "createdAt": "2020-08-28T06:50:26Z",
          "updatedAt": "2020-08-28T06:50:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good idea. I could totally imagine an extension where the proxy tells the client the outgoing port it used in its CONNECT-UDP reply, and then the client is allowed to ask for a preferred port when requesting CONNECT-UDP. This could be achieved via HTTP request/response headers.",
          "createdAt": "2020-08-28T18:11:56Z",
          "updatedAt": "2020-08-28T18:11:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:11Z",
          "updatedAt": "2020-12-13T04:42:11Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU2ODc2OTc0MDY=",
      "title": "Address mapping and return flow routing",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/5",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "Issue created by @martinthomson on [2020-04-16](https://github.com/DavidSchinazi/masque-drafts/issues/25):\r\n\r\nThe design here would appear to permit the use of 'Address and Port-Dependent Mapping' as defined in [Section 4.1 of RFC 4787](https://tools.ietf.org/html/rfc4787#section-4.1).  However, that document strongly recommends that an 'Endpoint-Independent Mapping' is used so as to make UNSAF methods work.  This document should define those rules.\r\n\r\nRelated #4.",
      "createdAt": "2020-08-28T04:11:51Z",
      "updatedAt": "2021-03-05T22:36:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-04-17:\r\n\r\nThe current text explicitly only allows \"Address and Port-Dependent Mapping\". It attempted to define those rules clearly in [section 6](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-6). UNSAF is currently considered out of scope and not supported. I'm not sure whether we want to increase the scope and add that complexity.",
          "createdAt": "2020-08-28T04:12:07Z",
          "updatedAt": "2020-08-28T04:12:07Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson can you elaborate on what you would like to see happen here? Ideally in the form of a PR?",
          "createdAt": "2020-12-13T03:52:46Z",
          "updatedAt": "2020-12-13T03:52:46Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "So at a minimal functionality wise is that a MASQUE client should be able to request to open additional destinations from the same proxy source address (ip+UDP port) so that the client can open for UDP flows that are return routed to the proxy for a client from an address the client didn't expect but later learned. This is also necessary to get some of the ICE scenarios with STUN/TURN servers and direct connections to work. This is a step between a general listening socket, and the strict bi-direcitonal 5-tuple connection that is currently defined. ",
          "createdAt": "2021-01-12T10:24:46Z",
          "updatedAt": "2021-01-12T10:24:46Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I will note that this issue describes an intermedia step between a server port (#35 ) and the basic 5-tuple. And I think it is fundamental aspects of the protocol design to enable this. ",
          "createdAt": "2021-01-12T17:39:11Z",
          "updatedAt": "2021-01-12T17:39:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "I think that there are two distinct use cases that might need to be treated as separate things.\r\n\r\n1. The client wants to initiate a flow toward a specific UDP endpoint.  For that you don't need to understand what IP and port the proxy is allocating and that address does not need to be accessible from other (remote) endpoints.  This would work for QUIC; it might work in some very limited peer-to-peer and media cases, but I consider that not especially likely.\r\n2. The client wants a UDP endpoint of its own to use.  For that, the request is really that the proxy allocate an IP+port for exclusive use of the client.  In this case, the proxy should probably communicate what it thinks the address is to the client (though the client might seek the opinion of a STUN server regarding a reflexive address).  This would be necessary for most RTP and peer-to-peer scenarios.\r\n\r\nMy suggestion here is to look into an extension, perhaps via a header field, for the second case and only promise the former without that extension being present.\r\n\r\nedit to clarify: I don't think that there is much value in a middle option where you can add remote addresses reachable from an assigned local address.",
          "createdAt": "2021-01-12T23:37:02Z",
          "updatedAt": "2021-01-12T23:47:20Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @martinthomson here, this would make for a useful extension.",
          "createdAt": "2021-01-13T00:39:19Z",
          "updatedAt": "2021-01-13T00:39:19Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2ODc2OTc4OTE=",
      "title": "Datagram-Flow-Id size limits",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/6",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by me on [2020-05-05](https://github.com/DavidSchinazi/masque-drafts/issues/26):\r\n\r\nAs of `connect-udp-00`, the `Datagram-Flow-Id` is [defined](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-5) as a [structured header of type sh-integer](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-18#section-3.3.1). The max value for those is 10^15-1, but in theory flow IDs can go up to 2^62-1 (~4*10^18). We should either:\r\n- specify an alternate encoding, such as [an sh-binary byte sequence with specified endianness and maximum width](https://lists.w3.org/Archives/Public/ietf-http-wg/2020AprJun/0077.html)\r\n- note that values over 10^15-1 cannot be encoded and reaching that flow identifier should trigger closing the HTTP/3 connection and restarting it",
      "createdAt": "2020-08-28T04:13:18Z",
      "updatedAt": "2020-12-13T04:42:14Z",
      "closedAt": "2020-12-13T04:42:13Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @LPardue on 2020-05-05:\r\n\r\nI think the lower limit is ok. As a tangent, it might play nice with H2 fallback that uses stream IDs which are restricted to 2^31",
          "createdAt": "2020-08-28T04:13:50Z",
          "updatedAt": "2020-08-28T04:13:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:13Z",
          "updatedAt": "2020-12-13T04:42:13Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU2ODc2OTgzNzg=",
      "title": "CONNECT-UDP should communicate MTU",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/7",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "Issue created by me on [2020-05-27](https://github.com/DavidSchinazi/masque-drafts/issues/27):\r\n\r\nCONNECT-UDP can be used across multiple proxy hops, and each of these hops can have a different MTU, so it could be useful for the client to be notified of the maximum DATAGRAM payload size that will make it across all the hops. This value could also change over time, so we could consider adding the ability to communicate that.",
      "createdAt": "2020-08-28T04:14:55Z",
      "updatedAt": "2021-10-06T21:25:02Z",
      "closedAt": "2021-10-06T21:25:01Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from me on 2020-07-24:\r\n\r\nThis might be best handled by an extension to CONNECT-UDP, but keeping the issue open for now.",
          "createdAt": "2020-08-28T04:15:11Z",
          "updatedAt": "2020-08-28T04:15:11Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I think we even might want a way to communicate MTU directly to the client with only one proxy hop as for datagram use the client potentially needs to indicate a lower MTU for downlink traffic when encapsulated by the proxy also to the server",
          "createdAt": "2020-11-11T13:53:21Z",
          "updatedAt": "2020-11-11T13:53:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm not sure I understand this issue. Shouldn't the client use DPLPMTUD? Maybe adding some other method of PMTUD helps but I don't know if the reasons are clear to everyone. For a single hop case, I'd expect the existing QUIC mechanisms to allow the detection of the maximum DATAGRAM payload size.",
          "createdAt": "2020-11-11T14:14:20Z",
          "updatedAt": "2020-11-11T14:14:20Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "The problem is that the server might need to reduce its packet size in order for the proxy to fit that packet into one QUIC tunnel datagram frame (alternatively the proxy could send too big packet in the streams but that might also not what we want). The client could indicate a smaller packet size to the server but it might need input from the proxy to know what the right size is. We could hard code that or the server could use some kind of PMTUD but given we have a trusted signalling channel, I think we should use it (and avoid guessing).",
          "createdAt": "2020-11-11T16:51:23Z",
          "updatedAt": "2020-11-11T16:51:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Oh so are you saying that there might be a use case for some QUIC extension that allows endpoints to signal possible MTUs to each other, and then MASQUE could leverage that directly or indirectly?",
          "createdAt": "2020-11-11T17:12:03Z",
          "updatedAt": "2020-11-11T17:12:03Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I was thinking about having a MASQUE signal from the proxy to the client (on the MASQUE/app layer) and then the client could use that to set max_packet_size towards the server in QUIC. Of course max_packet_size cannot be smaller than 1200 and you need this information before you send the first inner QUIC Initial packet. But details are to be worked out...",
          "createdAt": "2020-11-11T17:28:26Z",
          "updatedAt": "2020-11-11T17:28:26Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Thanks. So using draft-32 terminology `max_udp_payload_size` and this scenario\r\n\r\nclient -> Proxy1 -> Proxy2 -> target\r\n\r\nProxy1 knows proxy2's `max_udp_payload_size`, so it sends it back for the client to populate *it's* max_udp_payload_size TP? ",
          "createdAt": "2020-11-11T17:46:37Z",
          "updatedAt": "2020-11-11T17:46:37Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "Ups missed the terminology change...\r\n\r\nI think that's the original case David mentioned but even with only one proxy there might be a need for additional signal as the proxy can only talk to the client and not to the target server. With one proxy there are two QUIC connections - one between the client and the proxy that uses datagrams; and one between the client and the target server that uses stream. However, the proxy needs to take the UDP payload from server and fit into one datagram to the client. Potentially the client can guess what the maximum number of bytes it that a proxy can fit into a datagram or we can fix it as a requirement (or we can signal it explicitly), however, this number of less than max_udp_payload_size because there is the QUIC packet and datagram frame overhead. And then also somehow the target server would need to know that number to limit its UDP payload size (the QUIC max_udp_payload_size of the e2d connection between the client and server).  ",
          "createdAt": "2020-11-11T18:08:47Z",
          "updatedAt": "2020-11-11T18:08:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "The way I thought about it for the e2e QUIC connection is that the client takes the minimum of the known tunnel max_udp_payload_size, subtracts the overheads and advertises a smaller value to the target. \r\n\r\nHowever, that's not a complete answer. And is overly pessimistic if QUIC-aware proxying could be used.",
          "createdAt": "2020-11-11T18:50:49Z",
          "updatedAt": "2020-11-11T18:50:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue was opened before we split HTTP Datagrams out of CONNECT-UDP. This will be better handled at the HTTP Datagram layer, so I'm closing this issue in favor of https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/65",
          "createdAt": "2021-10-06T21:25:01Z",
          "updatedAt": "2021-10-06T21:25:01Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU2ODc2OTg4Mjg=",
      "title": "CONNECT-UDP needs a request target URI",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/8",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue created by me on [2020-08-13](https://github.com/DavidSchinazi/masque-drafts/issues/29):\r\n\r\n[connect-udp-00 s3](https://tools.ietf.org/html/draft-schinazi-masque-connect-udp-00#section-3) mainly copied most of the CONNECT-UDP design from CONNECT, but than goes against some existing HTTP semantics. In particular, every HTTP method is supposed to use URIs to represent their request target (this was mentioned in [RFC 7231 s2](https://tools.ietf.org/html/rfc7231#section-2) and clarified in [draft-ietf-httpbis-semantics s6.1](https://tools.ietf.org/html/draft-ietf-httpbis-semantics-10#section-6.1)). CONNECT and OPTIONS are noted as existing exceptions, but new methods are not allowed exceptions, to allow intermediaries to proxy unknown methods. CONNECT-UDP only cares about the authority (host and port) portion of the URI, so we can easily encode that as an URI and mandate that the path MUST be \"/\" and the query MUST be empty. The main open question is what scheme to use. We could either reuse https, or register a new one.",
      "createdAt": "2020-08-28T04:16:15Z",
      "updatedAt": "2021-01-04T16:17:23Z",
      "closedAt": "2021-01-04T16:17:23Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @mirjak on 2020-08-14:\r\n\r\ndraft-ietf-httpbis-semantics notes CONNECT as a special case because it's only used for tunnelling by proxies and usually not even implemented by the origin server. This is the same scenario as we have for any new connect method and I think we should therefore follow the same semantics as already defined for CONNECT.",
          "createdAt": "2020-08-28T04:16:39Z",
          "updatedAt": "2020-08-28T04:16:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment by @MikeBishop on 2020-08-14:\r\n\r\n`udp://target-host:port`?",
          "createdAt": "2020-08-28T04:17:13Z",
          "updatedAt": "2020-08-28T04:17:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "From IETF 109: Strong support in the room to go with:\r\n\r\n```\r\nmasque://target-host:port\r\n```",
          "createdAt": "2020-11-20T10:01:47Z",
          "updatedAt": "2020-11-20T10:01:47Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "I'm actually less sure about masque://. It seems naively like this URI would refer to \"do masque with this proxy\"",
          "createdAt": "2020-11-20T10:01:55Z",
          "updatedAt": "2020-11-20T10:01:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Agreed with @ekr. While `udp://` probably isn't right, `masque://` seems misleading.",
          "createdAt": "2020-11-22T19:00:57Z",
          "updatedAt": "2020-11-22T19:00:57Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:15Z",
          "updatedAt": "2020-12-13T04:42:15Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I say that you adopted `masque://` in the draft, however,  don't think we reached consensus on this. I recommend to reopen this issue and continue the discussion.",
          "createdAt": "2020-12-15T13:58:19Z",
          "updatedAt": "2020-12-15T13:58:19Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "I concur with Mirja here.",
          "createdAt": "2020-12-15T14:00:44Z",
          "updatedAt": "2020-12-15T14:00:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Re-opening, as this was not confirmed on the list.",
          "createdAt": "2020-12-15T14:38:59Z",
          "updatedAt": "2020-12-15T14:38:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Do we still need this issue now that we have #23? We definitely need one issue to keep the discussion open but having two makes things confusing.",
          "createdAt": "2020-12-30T16:57:14Z",
          "updatedAt": "2020-12-30T16:57:14Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Oh, likely not! I didn't realize #23 was also discussing this issue. Let's consolidate discussion over there.",
          "createdAt": "2021-01-04T16:17:23Z",
          "updatedAt": "2021-01-04T16:17:23Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU3MTc0OTQ2Nzc=",
      "title": "Just curious about \"0-length\" datagrams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/9",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I just opened an issue on HTTP/3 datagram: https://github.com/DavidSchinazi/draft-h3-datagram/issues/8. There I suggest that receiving an H3 DATAGRAM frame with 0-length payload is an H3_FRAME_ERROR. \r\n\r\nBut after the flow ID \"is taken off\" the usable payload could be 0. I just wanted to check that a MASQUE proxy is fine to send 0-length UDP datagrams back and forth to an origin. That seems to be as-designed.",
      "createdAt": "2020-10-08T16:31:22Z",
      "updatedAt": "2020-11-19T03:43:31Z",
      "closedAt": "2020-11-19T03:43:31Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "From reading RFC 768 and 2675, as far as I can tell UDP datagrams with an empty payload are allowed, so I don't think we need to do anything in CONNECT-UDP, they'll just work.",
          "createdAt": "2020-10-08T16:39:55Z",
          "updatedAt": "2020-10-08T16:39:55Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Yeah, there's a resolved issue on DATAGRAM where we explicitly wanted to allow this type of model, so I support keeping that.",
          "createdAt": "2020-10-08T17:14:24Z",
          "updatedAt": "2020-10-08T17:14:24Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing based on discussion, no action needed here.",
          "createdAt": "2020-11-19T03:43:31Z",
          "updatedAt": "2020-11-19T03:43:31Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU3MTgzNjM1OTg=",
      "title": "UDP Pacing and Bursting Limits",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/10",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Who SHOULD have the responsibility for rate pacing and preventing bursts > ~10 packets? I can imagine a few models:\r\n\r\n- The client paces DATAGRAM frames on the tunneled UDP connection: this would allow QUIC implementations to not change, at least in this respect, when running over MASQUE. It also hopes the outer connection congestion control and/or the proxy logic will not cause these frames/datagrams to bunch up at their egresses.\r\n- The tunneled connection is as bursty as it wants to be, but the outer connection is paced: this has issues with heavy connection multiplexing, and the achievable rate on the outer connection may have no relationship to the rate end-to-end.\r\n- The proxy applies pacing and burst limits at its UDP egress: it's not clear how the proxy would obtain the correct pacing rate without an explicit signal. Of course some UDP apps have no notion of these concepts, so then what?\r\n\r\nAnyway, I'm suspicious that a wild west approach with no advice at all will lead to suboptimal outcomes, though it would not break interop (I wouldn't suggest any MUSTs here). Not saying anything would also preclude any explicit signaling, if that turns out to be beneficial.\r\n\r\nArguably, this is a thing for Magnus's draft, but I suspect that, as with MTU, there is much stronger consensus that pacing is A Necessary Thing than all the IP header fields in that draft. The proxy has no mechanism to flow control datagrams, so some sort of check on egress would be nice to avoid becoming a DoS vector.",
      "createdAt": "2020-10-09T19:07:07Z",
      "updatedAt": "2020-12-13T04:42:18Z",
      "closedAt": "2020-12-13T04:42:17Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that insufficient pacing can cause serious performance issues in applications that run over UDP. However, that's not a property of UDP proxying, that's a property of the end-to-end application protocol. I like the idea of adding text to recommend that the proxy does not introduce additional burstiness by queueing packets and then sending out a burst at a time. However, I'm not convinced that any explicit signaling for this would be beneficial, so I'd rather leave that top extensions.\r\n\r\nOn the topic of the DoS vector, I'd suggest filing a separate issue but I'll say that CONNECT had the benefit of not letting the client send more than a SYN until the end server has responded with a SYN-ACK, so we may want to have limitations on how much traffic can be sent until we receive a response from the server. Though the trickiness is that in TCP the server can always send a RST to tell the proxy to stop sending, and we don't have an equivalent in UDP.",
          "createdAt": "2020-10-09T20:21:32Z",
          "updatedAt": "2020-10-09T20:21:32Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Upon further reflection, given a strong recommendation to not buffer datagrams at the proxy, the only performance issue I can see presupposes that we have two layers of congestion control, which is not a good presumption at this point.\r\n\r\nSo I agree that adding text discouraging buffering Datagrams for bursts will solve this issue.",
          "createdAt": "2020-10-09T21:01:18Z",
          "updatedAt": "2020-10-09T21:01:18Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "Buffering datagrams can be beneficial when the link capacity on the link between the proxy and client is unstable. However, I believe you are talking about not buffering data that is sent towards the server, right?",
          "createdAt": "2020-11-11T17:00:52Z",
          "updatedAt": "2020-11-11T17:00:52Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:17Z",
          "updatedAt": "2020-12-13T04:42:17Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU3MTg0MjM4NTU=",
      "title": "Limit Packets before server response",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/11",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "@DavidSchinazi in #10 suggested I file this as a separate issue.\r\n\r\nThe anonymization properties of MASQUE make it a nice vector to send out large bursts of datagrams to unsuspecting targets. It would be wise for MASQUE proxies to implement some sort of hard limit on datagrams it's willing to transmit without hearing anything from the server.\r\n\r\nOf course, the client here is working harder than either the proxy or the server, but it would be bad to get the proxy IP on a denylist.",
      "createdAt": "2020-10-09T21:09:02Z",
      "updatedAt": "2020-12-13T04:42:30Z",
      "closedAt": "2020-12-13T04:42:30Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:30Z",
          "updatedAt": "2020-12-13T04:42:30Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU3MTg0MjYxMTY=",
      "title": "Nested Congestion Control",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/12",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is a placeholder to discuss the effects/mitigations for nested congestion control, as required in the charter.",
      "createdAt": "2020-10-09T21:13:57Z",
      "updatedAt": "2020-12-13T04:42:19Z",
      "closedAt": "2020-12-13T04:42:19Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Among the ugly issues here is that inner connection QUIC ACKs might be congestion controlled by the outer connection, and/or scheduled behind potentially large amounts of data on other streams.",
          "createdAt": "2020-10-09T21:16:58Z",
          "updatedAt": "2020-10-09T21:16:58Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The way I think about this is that any router on the Internet implements a congestion controller. If we focus on a single direction of traffic, routers will have an input interface, and an output interface - if for some reason there are more packets coming into the input interface than the capacity of the output interface, then the router will have to exert control over that output link congestion, and its signaling mechanism is to drop some packets.\r\n\r\nWith that in mind, any TCP or QUIC connection going over the Internet has to deal with nested congestion controllers, and things work pretty decently. Going back to @martinduke's example from https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/12#issuecomment-706406176, any router can drop QUIC ACKs, and QUIC can handle that just fine.\r\n\r\nMy question is: how is a CONNECT-UDP proxy which can drop DATAGRAMs because of its congestion controller any different from a regular router than can drop packets due to its output link being saturated?\r\n\r\nTo clarify, I'm not suggesting we close this issue with no action - adding some notes explaining caveats sounds reasonable, but I don't see a need to develop an explicit solution to this problem.",
          "createdAt": "2020-10-10T21:12:54Z",
          "updatedAt": "2020-10-10T21:12:54Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I don't think this is a question of correctness (it doesn't create infinite loops or deadlocks), but one of performance.\r\n\r\nWhile is some respects routers have \"congestion controllers\", they are generally not probing the path bandwidth or measuring latency, just looking at their local queue occupancy. Maybe your answer is to simply drop all datagrams for which there isn't immediately available cwnd; that may work, though we'd have to think about whether or not that's better than queueing them.\r\n\r\nIn QUIC we specifically exempted pure ACKs from congestion control because we were concerned about deadlocks, as congestion control could block sending ACKs that would unblock the connection. I don't think that's an issue here. But bad choices for the proxy scheduler could result in large delay spikes on these acks.\r\n\r\nI'll spend some time thinking about corner cases, but fundamentally I don't have a problem with your proposal to simply add some caveats.",
          "createdAt": "2020-10-12T18:06:13Z",
          "updatedAt": "2020-10-12T18:10:49Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "The problem isn't that the masque proxy might drop packets; that's fine as that a congestion signal as any other signal from a router, as David said; usually this is called AQM and not congestion control though. The problem is that there are two actual congestion controllers which react to the same input signal (loss) and try to control the same output signal (rate) but operating on different time scales. In TCP the outer connection would conceal losses but add delay; so the inner connection you not get the input signal but see changes in delay that can negatively interact with the control loop as that's not the expected scenario. In QUIC when datagrams are use the losses are not concealed and both controllers react to the same input signal. However, if the outer tunnel QUIC connection between the client and the proxy is working on a much smaller time scale, it actually faster and it should be the limiting factor. Still, I think more work is needed here and also some text to acknowledge this in the draft.",
          "createdAt": "2020-11-11T17:12:05Z",
          "updatedAt": "2020-11-11T17:12:05Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "NONE",
          "body": "I would say that Davids point is valid for 3GPP radio, where an e/gNB buffers data and regulates the transmission rate based on a multitude of factors. In the case of RLC Acknowledged mode there is also nested loss recovery, though in this case losses are concealed similarly to what Mirja describes for the TCP case.\r\n\r\nI agree that some discussion on this topic is warranted, but I would be wary against making too clear recommendations such as ''drop packets when CWND limited\". ",
          "createdAt": "2020-11-12T10:52:18Z",
          "updatedAt": "2020-11-12T10:52:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:19Z",
          "updatedAt": "2020-12-13T04:42:19Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU3MTg0MjY3MzM=",
      "title": "Nested Loss Recovery",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/13",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is a placeholder to discuss the effects/mitigations for nested loss recovery, as required in the charter. Of course, this only applies to MASQUE running over HTTP versions with no DATAGRAM frames.",
      "createdAt": "2020-10-09T21:15:17Z",
      "updatedAt": "2020-12-13T04:42:21Z",
      "closedAt": "2020-12-13T04:42:21Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:21Z",
          "updatedAt": "2020-12-13T04:42:21Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU3Mjk3NzI3MTg=",
      "title": "Signal path change to end server?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/14",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "If there is an address migration or NAT rebinding on the MASQUE connection, it might be good to have a synthetic event of the same type on any related outgoing UDP flows (i.e. change the MASQUE proxy's server-facing port).\r\n\r\nPros:\r\n- servers can reset their path specific variables, especially MTU.\r\n\r\nCons:\r\n- Would break UDP connections that don't support multihoming (including some QUIC server deployments!) One could argue that exposing this kind of thing to the endpoint actually preserves end-to-end information, I guess.\r\n- The resulting path validation would not otherwise be necessary, as the MASQUE connection already validated it.\r\n\r\nGiven the tradeoffs, perhaps this is a MAY for MASQUE proxies.",
      "createdAt": "2020-10-26T17:41:48Z",
      "updatedAt": "2020-12-13T03:48:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "If we want way for the client to trigger an address change, we should make this explicitly by providing a way for the client to request that. However, I not sure what the use case is...?",
          "createdAt": "2020-11-11T17:14:34Z",
          "updatedAt": "2020-11-11T17:14:34Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "The use case is that the QUIC end server ought to reset its path variables if there has been an address migration. It is unnecessary but harmless for the server to validate the path.\r\n\r\nThere's a separate problem with Server Preferred Address. I'm not sure what the end client would do with that over a CONNECT-UDP tunnel.",
          "createdAt": "2020-11-11T23:20:07Z",
          "updatedAt": "2020-11-11T23:20:07Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU3MzY4OTI5ODg=",
      "title": "How do you salami slice CONNECT-UDP stream data?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/15",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "So I'd kinda forgotten that when H3 DATAGRAMS are not available (e.g. in HTTP/2 etc) CONNECT-UDP allows a mode where UDP datagram payload is transferred to the proxy as one contiguous bytestream of HTTP payload. How do receiving endpoints slice up this bytestream to ensure the atomic payloads are reconstructed properly? A proxy needs to make sure it sends the correct payload in the UDP datagram is will send, a client needs to construct the accurate UDP datagram payload in order to process whatever protocol it is tunnelling.\r\n\r\nThe specification doesn't say anything about how message boundaries might be signalled or acted upon. Is the intention maybe to rely on DATA frames for delineation? Implementations might not be able to guarantee that frames boundaries match 1:1. For instance quiche provides a r[ecv_body() method](https://docs.quic.tech/quiche/h3/struct.Connection.html#method.recv_body) to read arbitrary amounts of payload data from request streams; DATA rame boundaries are not exposed to applications.",
      "createdAt": "2020-11-05T12:29:46Z",
      "updatedAt": "2020-12-15T17:36:13Z",
      "closedAt": "2020-12-13T04:42:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "It's this, right?\r\n```\r\nIf HTTP/3 datagrams are not supported, the stream is used to convey UDP payloads, by prefixing them with a 16-bit length.\r\n```",
          "createdAt": "2020-11-05T16:22:29Z",
          "updatedAt": "2020-11-05T16:22:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I think so yes. I missed it somehow, so perhaps some editorial work would help improve things. For instance, the DATAGRAM frame supports up to 62-bit lengths but in this case case the frame is limited to 16 bits.\r\n\r\nIn the API I mentioned earlier, a proxy would need to try and read 2 bytes from the stream, then try to read as many bytes as the length indicated. That's certainly doable but needs a bit work in the application side. (those bytes might not be available, so the app needs to buffer things itself).\r\n\r\nIn the opposite direction there's a problem if the target presents datagrams with a length larger than can be expressed in 16 bits. We might want to highlight that the proxy can only drop these on the floor. Endpoints should be able to deal with that just like any PTB situation.",
          "createdAt": "2020-11-05T16:43:23Z",
          "updatedAt": "2020-11-05T18:27:05Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I actually thought that would be nice to use DATA frames as this would allow for more extensibility. How hard would it be to expose frame boundary for a masque implementation? Alternatively we could maybe define a new frame type?",
          "createdAt": "2020-11-11T17:18:49Z",
          "updatedAt": "2020-11-11T17:18:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:23Z",
          "updatedAt": "2020-12-13T04:42:23Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I saw that the new draft version proposes \"CONNECT-UDP Stream Chunk\". This looks like a good approach, however, I would still like to conclude the discussion why this is better than using HTTP DATA frames.",
          "createdAt": "2020-12-15T14:30:48Z",
          "updatedAt": "2020-12-15T14:30:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "My initial intuition is that Stream Chunks were conveyed in DATA frames. I'm wondering if I lept to the wrong conclusion.\r\n\r\nP.S: I also wondered if Stream Chunk should actually be an HTTP/3 frameset of its own. I think some minor editorialization that could help clarify things.",
          "createdAt": "2020-12-15T14:38:53Z",
          "updatedAt": "2020-12-15T14:38:53Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, Stream Chunks are conveyed over DATA frames. Stream Chunks have their own framing (as opposed to using the DATA frame boundaries) to simplify implementation, and to support HTTP/1.1 where there are no HTTP DATA frames.",
          "createdAt": "2020-12-15T17:36:13Z",
          "updatedAt": "2020-12-15T17:36:13Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU3MzY4OTUxNTI=",
      "title": "What purpose does datagram-flow-id fulfill?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/16",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think it might help to make the purpose of the datagram-flow-id header clearer in the specification.\r\n\r\nFor context, I was giving an overview of HTTP/3 CONNECT-UDP to someone completely new to MASQUE. The inclusion of a flow ID in the H3 DATAGRAM frame makes total sense, it's for multiplexing. However, in my example, the client made a request on stream ID 0 and used a datagram-flow-id of 0. Partly because of this overlap, the person I was presenting to made the comment \"why do you need the datagram-flow-id header, couldn't you just use the stream ID\"? Since the stream and datagram flow IDs have a linked lifetime, this observation makes some sense. \r\n\r\nThere might be benefits to having independence between stream ID and flow ID space. However, having reread the spec a few times now, I think the main purpose comes from the intention to be flexible. What I mean by that is, the use of HTTP/3 DATAGRAMS is opportunistic and that it is reasonable to fallback to carying tunnelled UDP datagram payload on streams. So, is the primary intention that \"datagram-flow-id\" is echoed in responses to allow clients to understand if they can use DATAGRAMS or if they have to use streams? \r\n\r\n",
      "createdAt": "2020-11-05T12:33:03Z",
      "updatedAt": "2020-12-17T17:28:21Z",
      "closedAt": "2020-12-13T04:42:25Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The purpose of the Datagram-Flow-Id header is to negotiate which flow ID to use. An alternative could be to use stream IDs, but that has downsides:\r\n- it means that we'll be more likely to use longer encodings for flow IDs\r\n- it needlessly ties the two namespaces (stream ID / flow ID) together, which prevents innovation - for example in [quic-proxy](https://tools.ietf.org/html/draft-pauly-masque-quic-proxy-00) we have multiple requests share a flow ID",
          "createdAt": "2020-11-05T17:26:53Z",
          "updatedAt": "2020-11-05T17:26:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Thanks for the clarification. That challenges my earlier statement that alluded to \"CONNECT-UDP sharing fate with the flow ID\", they actually have more independence. It might be worth saying something about flow ID reuse across requests, I presume that reuse is an error in the case of vanilla CONNECT-UDP but is fine in quic-proxy when requests are used for active flow ID manipulation?",
          "createdAt": "2020-11-05T17:44:25Z",
          "updatedAt": "2020-11-05T17:44:25Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I thought the main reason is that the QUIC stream ID is not exposed to the HTTP layer? However, even if a different stream ID is used on the QUIC layer, you could still use the datagram ID to remember the associated stream on the HTTP layer.",
          "createdAt": "2020-11-11T17:47:06Z",
          "updatedAt": "2020-11-11T17:47:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:25Z",
          "updatedAt": "2020-12-13T04:42:25Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi can you say a bit more here how this is addressed. I don't think I saw anything in the new docs that e.g. talk about re-use (or did I miss that?). I guess it would be helpful to say a bit more about how to handle flow ID then just saying there is a service doing it....",
          "createdAt": "2020-12-16T17:36:44Z",
          "updatedAt": "2020-12-16T17:36:44Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@mirjak yes, I need to add a few more clarifications, that work is tracked by https://github.com/DavidSchinazi/draft-h3-datagram/issues/9",
          "createdAt": "2020-12-17T17:28:21Z",
          "updatedAt": "2020-12-17T17:28:21Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU3MzY5MDYxMDA=",
      "title": "Consider error codes for the client to terminate CONNECT-UDP streams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/17",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "Imagine a client wants to talk HTTP to a server via a proxy.\r\n\r\nFor basic HTTP/3, the optimal case is to talk QUIC-in-QUIC via MASQUE and DATAGRAMs. But that requires the proxy (or chain of proxies) to support DATAGRAMs. So a client might discover via the CONNECT-UDP response that only the stream mode is available. \r\n\r\nTransferring QUIC over a reliable stream has some problems. A client might decide its not worth the effort and want to just fallback to HTTP over TLS (via just a CONNECT stream). At such a point, it would likely want to abort the stream and having an error code to indicate this could help the MASQUE server understand that this happened.\r\n\r\nThere's a variant of the above. Since the server can't judge UDP connectivity, it's upon the client to actively close the stream if it detects connectivity issues. An error code to this effect might also help.",
      "createdAt": "2020-11-05T12:50:12Z",
      "updatedAt": "2020-12-13T03:48:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "Actually I was wondering if there is any reason for the masque proxy to not support datagram mode (as long as datagrams are negotiated in the handshake of the QUIC tunnel connection underneath).\r\n\r\nHowever, not sure if we need to let the proxy know why a client aborts a stream. What should the proxy do with this information?",
          "createdAt": "2020-11-11T17:50:53Z",
          "updatedAt": "2020-11-11T17:50:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "More specific error codes could allow the proxy to detect a higher rate of client drop outs for a specific reason. That usefulness is debatable (hence this issue :)).\r\n\r\nThis specific chaining case is allowed by the specification, so we should assume that some deployment might end up using it. Dynamic deployments might find that the proxy chain conditions change in an uncoordinated way, finding why clients are grumpy via metrics is a lot easier than waiting for user reports.",
          "createdAt": "2020-11-11T19:16:08Z",
          "updatedAt": "2020-11-11T19:16:08Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU3NDAxMzEzOTg=",
      "title": "Additional options for CONNECT_UDP",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/19",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "There are several things in the IP layer that a normal application running over a UDP socket can control: ECN, DSCP, etc. Magnus's draft is a comprehensive list, but these are the two with the strongest case (ECN being particularly compelling, IMO).\r\n\r\nAs an individual, I would be sad if there was no way to use ECN for MASQUE except to do IP proxying. As an AD, I think this functionality would absolutely be in scope if we could form a consensus around it.\r\n\r\nI don't have a problem with support for this being optional, or even in a separate CONNECT-UDP extension draft, but I'm putting in issue here to preserve the discussion item. If the outcome is that someone needs to write an extension draft, I'm fine with that.",
      "createdAt": "2020-11-10T18:09:40Z",
      "updatedAt": "2020-12-13T03:54:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that there should be a mechanism that allows using ECN with CONNECT-UDP.\r\n\r\nHowever, I feel strongly that this shouldn't be a required part of CONNECT-UDP, because\r\n1. it's not required for a minimum viable product\r\n2. some operating systems don't let user-space applications access this data from received UDP packets\r\n\r\nHaving it be an optional part of the CONNECT-UDP spec could be doable, but I'd personally prefer it to be its own draft and extension to CONNECT-UDP. That will prevent this topic from delaying the main CONNECT-UDP document.",
          "createdAt": "2020-11-10T19:31:09Z",
          "updatedAt": "2020-11-10T19:31:09Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I think this is an important use that requires at minimum need to have some basic signalling mechanism build into the base protocol with a well defined extension point. However, if we do that, I think we can also specific the ECN signalling knowing that we want it. I would like to discuss how this could look like.",
          "createdAt": "2020-11-11T17:53:51Z",
          "updatedAt": "2020-11-11T17:53:51Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "What are the requirements of extensions such as this? \r\n\r\nI would hope that we can simply leverage the HTTP extension tools at our disposal rather than require anything additional. However, some of that hope depends on if extensions apply to a MASQUE tunnel connection, or individual CONNECT-UDP requests.\r\n\r\nI'm more on the side of doing any work in a separate document to CONNECT-UDP.  ",
          "createdAt": "2020-11-11T19:06:08Z",
          "updatedAt": "2020-11-11T19:06:08Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "One of the harder issues is that we probably need per-DATAGRAM of what ECN bits came in on the packet. The most straightforward way to do this is to have optional fields in the H3 DATAGRAM frame, though I can understand why people might not like that.",
          "createdAt": "2020-11-11T22:21:53Z",
          "updatedAt": "2020-11-11T22:21:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Oh, thanks for the clarification. ",
          "createdAt": "2020-11-11T22:30:23Z",
          "updatedAt": "2020-11-11T22:30:23Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "FWIW, I agree with @DavidSchinazi about this not going into the main draft.",
          "createdAt": "2020-11-22T22:33:36Z",
          "updatedAt": "2020-11-22T22:33:36Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "Even if this will be defined as an extension, we need to make sure we have the right extension point ready, e.g. for per-packet feedback. Also I think this is one of the base functions we should really support. I think we need more discussion based on a concrete proposal. Will try to work on this.",
          "createdAt": "2020-11-23T12:07:45Z",
          "updatedAt": "2020-11-23T12:07:45Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3NDY5MjE2NDk=",
      "title": "ICMP handling on the proxy",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/20",
      "state": "OPEN",
      "author": "obonaventure",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "With the CONNECT UDP, a proxy will send and receive UDP datagrams on behalf of a client. However, in addition to these UDP datagrams, it could also receive ICMP messages. The current draft does not discuss how these ICMP messages should be handled by a proxy and how they would need to be conveyed to the client. It probably makes sense to at least discuss how ICMP destination/network/port unreachable should be handled by the proxy (ignore, terminate the HTTP connection, ...)",
      "createdAt": "2020-11-19T21:01:55Z",
      "updatedAt": "2020-12-13T03:55:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree. I'm not yet sure what the best solution is (closing the stream on port unreachable would improve reliability but does introduce a way for an attacker to deny service) but we should figure that out and provide guidance in the doc.",
          "createdAt": "2020-11-19T21:55:10Z",
          "updatedAt": "2020-11-19T21:55:10Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "FWIW, the way TURN handles this is by having a way for the server to forward ICMP indications. \r\nhttps://www.rfc-editor.org/rfc/rfc8656.html#name-receiving-an-icmp-packet\r\n\r\nObviously, in order to have this in MASQUE we would need to have some sort of type indicator in the datagram.",
          "createdAt": "2020-11-22T22:32:47Z",
          "updatedAt": "2020-11-22T22:32:47Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I do want the relevant information in the ICMP to make it to the client. However, ICMP falls into the asynchronous information that is not directly associated with a forwarded packet. It can clearly be a forwarded packet per EKR's suggestion. We have other cases where we have information that is related to the associated packet, for example ECN. So I think this there is an important high level design choice here that we need to sorted out. I think for the general extensibility lets consider a content identifier so that just UDP payloads can be separated from additional types with additional fields. ",
          "createdAt": "2020-11-23T10:07:32Z",
          "updatedAt": "2020-11-23T10:07:32Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU3NTcyMTYzODE=",
      "title": "Handling of odd-numbered \"datagram-flow-id\"  ",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/21",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When processing a CONENCT-UDP request a server might apply some checks to decide if the request is valid. First, does the request contain a \"datagram-flow-id\", second is the value a valid sh-integer, and third is the value a valid client-initiated flow ID (even numbered).\r\n\r\nThe spec doesn't really talk about that third condition. And there is an interesting interplay with https://tools.ietf.org/html/draft-schinazi-quic-h3-datagram-05, which states requirements on flow ID allocation but clearly highlights that DATAGRAMs can be sent with even or odd flow IDs by either endpoint.\r\n\r\nWhile we continue to use flow ID with CONNECT-UDP, I think it might help to add some text about what a server should do.",
      "createdAt": "2020-12-04T16:07:40Z",
      "updatedAt": "2020-12-13T04:42:26Z",
      "closedAt": "2020-12-13T04:42:26Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:26Z",
          "updatedAt": "2020-12-13T04:42:26Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU3NTg2Mzc3MTg=",
      "title": "Handling of \"in-use\" flow IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/22",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Slightly related to #21 but image the following scenario that uses syntactically valid flow IDs\r\n\r\nFirst\r\n```\r\n:method: CONNECT-UDP\r\n:path: example.com:443\r\n:authority: example.com:443\r\ndatagram-flow-id: 0\r\n\r\nstatus: 200\r\n\r\n<datagram exchanges>\r\n```\r\n\r\nSecond\r\n```\r\n:method: CONNECT-UDP\r\n:path: other.example.com:443\r\n:authority: other.example.com:443\r\ndatagram-flow-id: 0\r\n\r\nstatus: ???\r\n```\r\n\r\nThe second request should probably be rejected with a 4xx error. The spec alludes to that possibility (apart from the weird bit about \"governed by\":\r\n\r\n> Any response other than a successful response indicates that the tunnel has not yet been formed and that the connection remains governed by HTTP.\r\n\r\nI think it might help to call this error condition out more explicitly.\r\n",
      "createdAt": "2020-12-07T16:02:17Z",
      "updatedAt": "2020-12-13T04:42:28Z",
      "closedAt": "2020-12-13T04:42:28Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in today's update to the drafts.",
          "createdAt": "2020-12-13T04:42:28Z",
          "updatedAt": "2020-12-13T04:42:28Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3NjU3Mjc1OTM=",
      "title": ":scheme",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/23",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[RFC 7540](https://tools.ietf.org/html/rfc7540#section-8.3) requires that CONNECT requests omit the `:scheme` pseudo-header:\r\n\r\n>   The \":scheme\" and \":path\" pseudo-header fields MUST be omitted.\r\n\r\nWhy does this draft need to define a URI scheme and then include that in `:scheme`?\r\n\r\nThere are already two different definitions for `udp:` URI scheme.  Both seem - at least on face value - fairly sensible, but they both come with considerable baggage.\r\n\r\nThe question I'd like to ask is whether this protocol even needs a URI scheme at all.  My first inclination is very much that it does not.",
      "createdAt": "2020-12-14T00:34:36Z",
      "updatedAt": "2021-09-11T16:19:14Z",
      "closedAt": "2021-09-11T16:19:14Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I added the scheme because I thought it was required (and [folks in the room at IETF 109 seemed to think it was required too](https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/8#issuecomment-731071289)), but maybe it isn't.\r\n\r\nUnfortunately, CONNECT-UDP is distinct from CONNECT, so it cannot benefit from the exception that CONNECT has. This is pretty explicit in [draft-ietf-httpbis-semantics s6.1](https://tools.ietf.org/html/draft-ietf-httpbis-semantics-10#section-6.1):\r\n> the request target is a URI reference\r\n> For CONNECT, the request target is the host name and port number\r\n> These forms MUST NOT be used with other methods.\r\n\r\nThis means that, unlike CONNECT, CONNECT-UDP needs a URI reference.\r\n\r\nHowever, according to [RFC 3986](https://tools.ietf.org/html/rfc3986):\r\n\r\n> URI-reference = URI / relative-ref\r\n> URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\r\n> relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ]\r\n> relative-part = \"//\" authority path-abempty / path-absolute / path-noscheme / path-empty\r\n> path-abempty  = *( \"/\" segment )\r\n> authority = [ userinfo \"@\" ] host [ \":\" port ]\r\n\r\nSo, if we go the route of `URI-reference = relative-ref = relative-part = \"//\" authority path-abempty` I think we can legally say that CONNECT-UDP request targets are of the form `\"//\" host \":\" port` and require the `:scheme` and `:path` pseudo-headers to not be sent. This would allow us to use URIs without schemes for CONNECT-UDP.\r\n\r\nCan someone who's more of an HTTP guru comment on this please? @martinthomson @mnot @MikeBishop",
          "createdAt": "2020-12-14T01:06:44Z",
          "updatedAt": "2020-12-14T01:06:44Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "It's an intriguing approach, but I'm not sure it works.\r\n\r\nSEMANTICS 4.1 says:\r\n\r\n> Each protocol element in HTTP that allows a URI reference will indicate in its ABNF production whether the element allows any form of reference (URI-reference), only a URI in absolute form (absolute-URI), only the path and optional query components, or some combination of the above. Unless otherwise indicated, URI references are parsed relative to the target URI (Section 7.1).\r\n\r\nI don't see anywhere in SEMANTICS it specifies that a method's target URI can't be relative.  However, for HTTP/1.1 at least:\r\n\r\n> When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client must send the target URI **in absolute-form** as the request-target.\r\n\r\n`absolute-form` does not permit the use of relative URIs.\r\n\r\nSince support for this method is negotiated in SETTINGS for HTTP/2 and HTTP/3, it's possible for it to depart from the general requirements for which pseudo-headers to send and specify something that looks more like CONNECT (omit `:scheme` and `:path`, for example).  However, I'm not convinced that can be generalized.\r\n\r\n@RoyFielding and @reschke, thoughts?",
          "createdAt": "2020-12-14T17:15:50Z",
          "updatedAt": "2020-12-14T17:15:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@MikeBishop support for CONNECT-UDP is not gated by a SETTINGS parameter. Only the datagram mode in h3 has a setting.",
          "createdAt": "2020-12-14T18:05:42Z",
          "updatedAt": "2020-12-14T18:05:42Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Ah, then it would need to include `:scheme` and `:path` pseudo-headers; I'm not sure off-hand if it's valid for those to be empty.",
          "createdAt": "2020-12-14T18:28:19Z",
          "updatedAt": "2020-12-14T18:28:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "I think that I would prefer a setting.  It's probably true that this doesn't require special handling, but there are intermediaries that do crazy things like buffer request bodies.  A setting would avoid any potential for misunderstanding.  It makes this unusable in HTTP/1.1, but I might see that as more of a feature than a bug.",
          "createdAt": "2020-12-14T22:20:31Z",
          "updatedAt": "2020-12-14T22:20:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I would strongly prefer to avoid a setting, as it breaks the [MASQUE Obfuscation](https://tools.ietf.org/html/draft-schinazi-masque-obfuscation) use-case.",
          "createdAt": "2020-12-14T23:49:44Z",
          "updatedAt": "2020-12-14T23:49:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "I tend to think that defining a URI scheme (perhaps not `udp:`) is the path of least resistance here, and I don't see any immediate harm in doing so. As a thought experiment, consider how the Web would work if CONNECT had a URI scheme; that would give a distinct way to convey proxy configuration, for example. \r\n\r\nBased on the above I also think we need to clarify in Semantics that a target-uri is always absolute, even if it is transmitted as a relative uri.\r\n\r\n",
          "createdAt": "2020-12-15T00:07:55Z",
          "updatedAt": "2020-12-15T00:07:55Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "For your obfuscation goals, the client needs to initiate any feature detection and do so after or in parallel with authentication.  So you're right, probably that precludes a setting unless you're using client certs to authenticate (which would itself be visible on a probe, though not clear evidence of Masque).  Then I agree with @mnot, that your path of least resistance is to mint a scheme for a UDP connection.\r\n\r\nThe fact that `udp://` has been used to describe other services available over UDP is regrettable, since those services actually intended to convey certain protocol endpoints.  In this instance, you are literally describing a UDP connection with no protocol-specific properties; I'd consider asking @dthaler if he'd be willing to have the provisional registration (which [he did as an experiment](https://datatracker.ietf.org/meeting/88/materials/slides-88-appsawg-9/)) replaced by a permanent one that simply designates `udp://` as describing a UDP endpoint without conveying application-layer protocol expectations.",
          "createdAt": "2020-12-15T16:22:11Z",
          "updatedAt": "2020-12-15T16:22:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking about this some more, could we use the \"https\" scheme? I really like @mnot's [idea](https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/23#issuecomment-744853126) to use a URI for proxy configuration, as that could allow future extensibility. [Chrome already uses URIs for proxy config](https://chromium.googlesource.com/chromium/src/+/HEAD/net/docs/proxy.md#https-proxy-scheme) and the \"https\" scheme there already maps TCP to the CONNECT method. I think it would make sense to have that also map UDP to CONNECT-UDP. And with that mindset, having the scheme sent over the wire as \"https\" seems natural, and bypasses the need to define a new URI scheme. Thoughts?",
          "createdAt": "2020-12-30T17:02:31Z",
          "updatedAt": "2020-12-30T17:02:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Can you explain a bit more please David? I'm vaguely familiar with Chrome's URI format of proxy configuration. \r\n\r\nI note that the link you provide also defines THR \"quic\" scheme. And I presume that it would be nice to ditch that some something more consistent. IIRC it is possible for a proxy identified by \"http\" or \"https\" schemes to offer H3 as an Alt-Svc. And then it's upon the client to decide how to tunnel requests through such a proxy that might be capable of talking CONNECT and CONNECT-UDP. \r\n\r\nIf this is too far off tangent (because of discovery) , we don't need to explore it here.\r\n\r\n ",
          "createdAt": "2020-12-30T17:21:49Z",
          "updatedAt": "2020-12-30T17:21:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue I totally agree with you, Chrome's \"quic\" scheme is historical and I think it should now be deprecated in favor of \"https\" (and rely on Alt-Svc to use h3). But yes this is somewhat of a tangent that we may want to discuss offline. I was simply trying to make the case that there was some sort of precedent to consider proxying using CONNECT as \"https\".\r\n\r\nBack to the scheme discussion, since the scheme carries no useful information on CONNECT-UDP requests, I'm proposing to simply use \"https\".",
          "createdAt": "2020-12-30T17:39:58Z",
          "updatedAt": "2020-12-30T17:39:58Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "That all works for me.  It doesn't adhere to any sort of architectural purity, but CONNECT has no hope of achieving that; hoping to include some notion of purity along other design constraints would only make things worse.\r\n\r\nI like the idea that you can just use \"https\" and work out the rest using the protocol negotiation tools we have (Alt-Svc, HTTPS, settings).",
          "createdAt": "2021-01-04T00:53:26Z",
          "updatedAt": "2021-01-04T00:53:26Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I think some discussion in this thread, but likely not fully what the intended semantics of the URI scheme should be. I think there are two basic ones that I can think of and the first one is:\r\n\r\nA) Use a MASQUE proxy to send packets to \"target address\"\r\n\r\nHowever, I would think that outside of the MASQUE protocol a more useful URI semantics would be:\r\n\r\nB) Use this MASQUE proxy to send traffic to this target address.\r\n\r\nI also think we have to take a step back and ask ourselves if MASQUE URI scheme implies UDP or it it should use parameters to encode which protocol that should be proxied over the MASQUE proxy? \r\n\r\nThe other aspect in this country I think the A) semantics in the -03 connect-udp draft is that is it doesn't discuss the identity of the proxy. For the security aspect the MASQUE client need to know the identity of the proxy so that it can verify the initial H/3 connection to the MASQUE proxy. \r\n\r\n",
          "createdAt": "2021-01-12T10:41:46Z",
          "updatedAt": "2021-01-12T10:41:46Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we simply recommend using `https` as the scheme, but allow clients to specify a different scheme if appropriate?",
          "createdAt": "2021-01-12T23:19:54Z",
          "updatedAt": "2021-01-12T23:19:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "After discussion at the meeting, my understanding is that the target resource CONNECT-UDP might be an origin that speaks CONNECT-UDP, or it might be a 'raw' UDP endpoint.\r\n\r\nIn the former case, a HTTPS schemed target URI makes sense; in the latter, something new is necessary (e.g., `udp://`, if we can make that interoperable).",
          "createdAt": "2021-01-12T23:21:00Z",
          "updatedAt": "2021-01-12T23:21:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "given that the authority component of an `https://` URI would not need to be aware of CONNECT-UDP, I am not sure that this reasoning for `https://` works for me.  IOW, it implies that a new scheme is good.\r\n\r\nI think that `udp://` is doubly burned already, unfortunately.",
          "createdAt": "2021-01-12T23:23:03Z",
          "updatedAt": "2021-01-12T23:23:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "@martinthomson if we required a new scheme for every new method introduced, we'd have some problems. Why is that necessary?",
          "createdAt": "2021-01-12T23:23:49Z",
          "updatedAt": "2021-01-12T23:23:49Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "I wasn't arguing for anything in particular, just looking for you (or someone) to address the problem somehow.",
          "createdAt": "2021-01-12T23:29:45Z",
          "updatedAt": "2021-01-12T23:29:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given that we don't care about the scheme for now, and want to make sure people ignore it on receipt, how about we do https:// by default, but say that clients SHOULD grease the scheme? \ud83d\ude01",
          "createdAt": "2021-01-14T00:35:21Z",
          "updatedAt": "2021-01-14T00:35:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "FWIW, I tend to think that we should omit scheme, path, and use SETTINGS for HTTP/2 and HTTP/3.\r\n\r\nAs @martinthomson points out, we have to make sure that servers unaware of CONNECT-UDP do not mishandle CONNECT-UDP requests.\r\n\r\nFor HTTP/2 and /3, we can go with either using sending SETTINGS or send `:scheme` set to something else than `https` or `http` as well as sending a fake `:path`.\r\n\r\nBut in HTTP/1, there's no way of sending a scheme, therefore, we'd have to use a connect-style request line (i.e. `CONNECT-UDP host:port HTTP/1.1). Otherwise, servers unaware of the method would handle it as an ordinary request.\r\n\r\nThe latter point means that there's practical advantage in following the style of CONNECT method. Then, why not use a SETTINGS on H2 and H3 to minimize the difference between H1 and H2/H3?",
          "createdAt": "2021-03-01T08:08:38Z",
          "updatedAt": "2021-03-01T08:12:16Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "It's actually legal to send a fully-qualified URI in HTTP/1.1; that's just not the common case when you're talking to an origin server.  I don't think it's a problem to be considering a full URI for CONNECT-UDP in HTTP/1.1.  Of course, if we know there's a lack of support for that form, that's a different issue.",
          "createdAt": "2021-03-01T16:26:05Z",
          "updatedAt": "2021-03-01T16:26:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "@MikeBishop \r\n> It's actually legal to send a fully-qualified URI in HTTP/1.1; that's just not the common case when you're talking to an origin server. I don't think it's a problem to be considering a full URI for CONNECT-UDP in HTTP/1.1. Of course, if we know there's a lack of support for that form, that's a different issue.\r\n\r\nThat's a good point. Regarding the concern that you point out, I'm not sure if that would actually be an issue because a request in absolute-URI form will be considered malformed and rejected by a server that only supports HTTP/1.0-style requests.\r\n\r\nHowever, there's the other failure mode, and that is servers ignoring the scheme. IIUC, most origin servers do not have the incentive to consult and reject requests based on the scheme.\r\n\r\nWhen I send `GET masque://server/ HTTP/1.1` to some host, I do see 200 responses, from servers hosted by large IaaS operators / multiple CDNs<sup>note 1</sup>. When sending `GET server:port HTTP/1.1` to those servers, I do see 4xx errors.\r\n\r\nTherefore, if we are to care about how existing HTTP/1.1 servers would respond to masque, I think that using the form of `CONNECT-UDP host:port` is going to provide us better results.\r\n\r\nnote 1: I'd take part of the blame, because h2o simply drops the scheme when receiving an HTTP/1.1 request. I'm glad that we are not alone!",
          "createdAt": "2021-03-01T23:43:07Z",
          "updatedAt": "2021-03-01T23:43:07Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The more I'm thinking about this, the more I'm leaning towards the simplest solution: no SETTING, and simply use a scheme of `https`. That works perfectly for everything we need, and carries the least complexity.",
          "createdAt": "2021-03-03T04:00:16Z",
          "updatedAt": "2021-03-03T04:00:16Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi I'm not sure if we'd be fine with the failure mode associated to that approach?\r\n\r\nHTTP servers (or applications) often buffer the entire request, before they start processing it. Even the method is being checked after all the request body is being received.\r\n\r\nWhen a client connects to such a server, sending a CONNECT-UDP request with an https URI, the server will hang forever, as the client never closes the request stream. Eventually, a timeout would kick in, but I do not think it's preferable to keep the client waiting until a timeout?\r\n\r\nAm I missing something, or is it the case that you are fine with relying on a timeout?",
          "createdAt": "2021-03-03T04:59:32Z",
          "updatedAt": "2021-03-03T04:59:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@kazuho thanks for clarifying - that's a good argument for a SETTING (at least in the server-to-client direction). However, I really dislike the idea that every new HTTP method needs its own SETTING... But apart from switching to extended CONNECT I'm not seeing a lot of alternate solutions. \ud83e\udd14 ",
          "createdAt": "2021-03-03T16:52:44Z",
          "updatedAt": "2021-03-03T16:52:44Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "None of this makes any sense. If you can't send a valid request, then this protocol does not belong anywhere near an HTTP stream. Figure out how to send a valid request or build your own protocol.",
          "createdAt": "2021-03-03T17:05:52Z",
          "updatedAt": "2021-03-03T17:05:52Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@royfielding how do you define a valid request? The issue here is that a CONNECT (or CONNECT-UDP) request is valid as far as our understanding of the HTTP specs, but that doesn't mean that servers handle them correctly - the important difference is that these requests are not followed by a FIN on the stream, and some servers don't handle that well, even if it's valid.",
          "createdAt": "2021-03-03T18:00:27Z",
          "updatedAt": "2021-03-03T18:00:27Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "I have never met a server that didn't handle an HTTP request \"well\", for its own definition of well. A server that doesn't know the method will use the standard parsing algorithm and respond at the end of the header section with a 405 or 501, depending on taste. If you want that to be faster, send fewer header fields. This is not a concern in practice.\r\n\r\nThere is no option to send host:port with CONNECT-UDP. That is not HTTP. Stop bringing it up.\r\n\r\nObviously, sending a GET request to a server is not the same as sending CONNECT-UDP to a server. The two have entirely different backwards-compatibility algorithms. Likewise, sending an absolute URI within a CONNECT-UDP request works just fine for every server chain that might be expected to support such a request, and the response is going to be 501, 405, or 400 for those that don't.\r\n\r\nIf you find a deployed server that evidences any other form of behavior, send the developers a bug report. The IETF is not the place to work around every possible fool's implementation of bad parsing. By the time you finish writing the spec, there will be at least three more ways to fail to implement that spec correctly. Focus instead on making it work for servers that implement HTTP correctly.",
          "createdAt": "2021-03-03T18:28:24Z",
          "updatedAt": "2021-03-03T18:28:24Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "No HTTP requests are followed by a FIN on the stream. FIN is part of TCP.\r\n\r\nClients do not half-close their sockets in HTTP/1.1 -- the end of a request is indicated by either the end of the header section or by the end of the request Content-Length's amount of data, and the server doesn't read past that until it looks for the next request (on a persistent connection). A server sends FIN after closing their end of the TCP connection.\r\n\r\nFor HTTP/2 and HTTP/3, both requests and response occur within protocol frames. A FIN only occurs when the underlying connection breaks.",
          "createdAt": "2021-03-03T20:09:34Z",
          "updatedAt": "2021-03-03T20:09:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@royfielding my comment about the FIN was specific to HTTP/2+. With those versions, the client sends a FIN on the request stream when it is done sending the body (or the headers when there is no body) for non-CONNECT requests. Some servers have unfortunately come to expect that of all request types, leading to timeouts for CONNECT.",
          "createdAt": "2021-03-03T20:15:49Z",
          "updatedAt": "2021-03-03T20:15:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "@royfielding I get your argument that sending CONNECT-style host:port is an act of breaking HTTP. Though, I would argue that if we are to stay within HTTP, we have to use a hop-by-hop opt-in mechanism for CONNECT-UDP, because it breaks existing assumption within HTTP that servers can wait for a complete request before processing it.\r\n\r\nTo that end, I tend to believe that we have to do the following:\r\n* For HTTP/2 and /3, use SETTINGS, like we did in RFC 8441.\r\n* If we need support for HTTP/1.1, use upgrade, like we did in RFC 6455, RFC 7540.\r\n\r\n@DavidSchinazi \r\n> However, I really dislike the idea that every new HTTP method needs its own SETTING... But apart from switching to extended CONNECT I'm not seeing a lot of alternate solutions.\r\n\r\nWe do not have to add a new SETTING parameter for every new type of tunnel. Assuming that we are fine with using SETTINGS, I tend to wonder if we could reuse RFC 8441. With that opt-in UDP tunnels can be created by using a CONNECT request (rather than a new method), with a scheme used for identifying that the payload is UDP datagrams?",
          "createdAt": "2021-03-03T21:22:52Z",
          "updatedAt": "2021-03-03T21:22:52Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "> it breaks existing assumption within HTTP that servers can wait for a complete request before processing it.\r\n\r\nThere is no such assumption in HTTP. The request is complete when the header section is complete.",
          "createdAt": "2021-03-03T21:44:18Z",
          "updatedAt": "2021-03-03T21:44:18Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "NONE",
          "body": "IOW, if a server doesn't start processing a request message as soon as the header section is complete, it cannot correctly implement Expect and it probably doesn't support request content delimited by Transfer-Encoding or Content-Length. HTTP is designed for infinite length content streams, so there are no cases where we assume a recipient will wait until the end of the message body before starting to process the request. There would be no distinction between that and a denial-of-service vulnerability.",
          "createdAt": "2021-03-03T22:00:46Z",
          "updatedAt": "2021-03-03T22:00:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "@royfielding Sorry my phrasing was incorrect. What I meant to say was that HTTP does not assume servers to start sending a final response before receiving _end of the stream_ ~~entire request body, unless the method is CONNECT~~.\r\n\r\nEDIT. After initially posting this comment, I realized that for HTTP/1.1, lack of CL or TE indicates that the end of request headers is the end of the request. But for HTTP/2 and HTTP/3, the method being CONNECT is the only indicator that changes where the request ends, isn't it?",
          "createdAt": "2021-03-03T23:17:02Z",
          "updatedAt": "2021-03-03T23:30:09Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "NONE",
          "body": "FWIW, if all you need is *something* that is a valid URI (and the content does not matter), a URN might work perfectly well:\r\n\r\n    urn:ietf:rfc:xxxx\r\n\r\n(see https://tools.ietf.org/html/rfc2648).\r\n\r\n(I think Ted Hardie mentioned this in the IETF meeting chat)\r\n\r\n",
          "createdAt": "2021-03-10T08:21:29Z",
          "updatedAt": "2021-03-10T08:52:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "@enygren mentioned elsewhere that a locator that identifies the server providing the connect tunnel would be much better than the current design, which effectively puts the target host as an authority.  I'm not yet sure what I think of that, but it's an interesting thought worth considering.",
          "createdAt": "2021-03-10T14:30:18Z",
          "updatedAt": "2021-03-10T14:30:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is the example from @enygren's [email to the list](https://mailarchive.ietf.org/arch/msg/masque/e-N94oNVcED-svuhNzZn5zYjW9w/):\r\n\r\n```\r\n:method = CONNECT-UDP\r\n:authority = masque-proxy.example.net\r\n:path = /www.example.com?port=3568\r\n:scheme = https\r\n```",
          "createdAt": "2021-03-10T15:45:44Z",
          "updatedAt": "2021-03-10T15:45:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "That specific example makes my RFC 8820 sense itch, but it's an OK illustration of the idea.",
          "createdAt": "2021-03-10T15:47:24Z",
          "updatedAt": "2021-03-10T15:47:24Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson do you have an alternate encoding that would appease your itch?",
          "createdAt": "2021-03-10T15:48:26Z",
          "updatedAt": "2021-03-10T15:48:26Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "With the https scheme, we might be able to use a URI template (which might lead to that exact example if people so chose).  Or we could define a new scheme...",
          "createdAt": "2021-03-10T15:49:43Z",
          "updatedAt": "2021-03-10T15:49:43Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "@tfpauly pointed out that draft-pauly-dprive-oblivious-doh does something similar.  It may make sense to have some consistency.  Maybe:\r\n\r\n```\r\n:method = CONNECT-UDP\r\n:authority = masque-proxy.example.net\r\n:path = /.well-known/connect-udp?targethost=www.example.com&targetport=3568\r\n:scheme = https\r\n```\r\n\r\n(perhaps adjusting the path somehow, or using a URI template?)",
          "createdAt": "2021-03-10T15:50:41Z",
          "updatedAt": "2021-03-10T15:50:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the idea of keeping the https scheme and using the path to convey the target",
          "createdAt": "2021-03-10T16:12:14Z",
          "updatedAt": "2021-03-10T16:12:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "No need to abuse .well-known when we can use a URI template.",
          "createdAt": "2021-03-10T16:15:03Z",
          "updatedAt": "2021-03-10T16:15:03Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "NONE",
          "body": "...as in something using curly brackets...?",
          "createdAt": "2021-03-10T16:18:38Z",
          "updatedAt": "2021-03-10T16:18:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "https://datatracker.ietf.org/doc/html/rfc6570",
          "createdAt": "2021-03-10T16:19:15Z",
          "updatedAt": "2021-03-10T16:19:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "So something like `:path = /{target_host}/{target_port}/` ?",
          "createdAt": "2021-03-10T16:21:06Z",
          "updatedAt": "2021-03-10T16:21:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "That would be an easy way of doing it.  Or `/mask?h={host}&p={port}`.",
          "createdAt": "2021-03-10T16:22:11Z",
          "updatedAt": "2021-03-10T16:22:11Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "NONE",
          "body": "But that would be an invalid path.",
          "createdAt": "2021-03-10T16:23:20Z",
          "updatedAt": "2021-03-10T16:23:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Would it be invalid after RFC 6570 substitution?",
          "createdAt": "2021-03-10T16:24:28Z",
          "updatedAt": "2021-03-10T16:24:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "NONE",
          "body": "*After* substitution is of course ok.\r\n\r\nSo *where* do you want to put the template?",
          "createdAt": "2021-03-10T16:25:53Z",
          "updatedAt": "2021-03-10T16:25:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "The template goes the same place you might put a URL.  Right now, that is configuration.",
          "createdAt": "2021-03-10T16:31:16Z",
          "updatedAt": "2021-03-10T16:31:16Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "NONE",
          "body": "Ah, I thought you wanted to put it into the \":path\" pseudo header.",
          "createdAt": "2021-03-10T16:32:48Z",
          "updatedAt": "2021-03-10T16:32:48Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "Closely related to this is whether:\r\n1) Use a method per protocol (CONNECT-UDP, CONNECT-IP, etc)\r\n2) Use a new common method (eg, CONNECTX) with protocol in either a pseudoheader or path component\r\n3) Use Extended CONNECT with a \":protocol\" psuedoheader\r\n\r\nGiven all of the baggage with CONNECT, I'd lean towards (2)",
          "createdAt": "2021-07-27T00:39:22Z",
          "updatedAt": "2021-07-27T00:39:34Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "(This issue probably wants a more general name covering the set of interrelated topics here.)",
          "createdAt": "2021-07-27T00:40:26Z",
          "updatedAt": "2021-07-27T00:40:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "@enygren \r\n> Given all of the baggage with CONNECT, I'd lean towards (2)\r\n\r\nAs said at the meeting, to avoid intermediaries unaware of masque waiting for FIN before doing anything, I think it would be a good idea to make this an opt-in. For that, we need to use an ALPN, SETTING, or something that it being exchanged prior to the HTTP requests.\r\n\r\nThe problem with option 1 is that we'd need to introduce a new negotiation scheme for every protocol.\r\n\r\nOption 2 is better in that respect because we need to introduce one negotiation scheme, and reuse it for different protocols.\r\n\r\nBut I'm not sure if hawing a new negotiation scheme is necessary, when option (3), i.e., the Extended CONNECT method, already provides us the necessary negotiation scheme with the \":protocol\" psuedo header acting as a way of specifying the protocol.",
          "createdAt": "2021-07-27T05:56:06Z",
          "updatedAt": "2021-07-27T05:56:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Extended CONNECT does have the advantage of targeting a resource.  The challenge then is in how the target (for UDP, that would be a hostname or IP plus a port) is encoded into that target URI.  We have URI templates that have been successfully used elsewhere, so that might work.  Webtransport can just use an arbitrary target URI.\r\n\r\nThe main complaint I have is that :protocol is terrible.  HTTP Upgrade Tokens aren't ALPN, but that's almost what we want here: a unified protocol identification system.  Of course, as a tunneled protocol, ALPN isn't right either, so maybe we can just reclaim upgrade tokens for this tunneling stuff.",
          "createdAt": "2021-07-27T07:29:58Z",
          "updatedAt": "2021-07-27T07:29:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "Yeah, I share the temptation to use ALPN. Though, talking specifically about masque, I'm not sure if it's an application protocol. Rather, it is a combination of an encapsulated datagram protocol and a way of specifying the remote address.\r\n\r\nLet's say we want to use SRTP on top of a HTTP tunnel with support for datagrams. In such case, SRTP would be the ALPN, and we'd need another identifier for specifying that the transport carries datagrams, rather than a bidirectional stream.\r\n\r\nBased on that, I am inclined to say that \":protocol\" might be a better fit for masque, and separately, we could discuss adding a non-pseudo header field for specifying ALPN.\r\n\r\nPS. And the other benefit of using Upgrade Tokens is that we can support HTTP/1.1 as well (though I'm not entirely sure if we want to officially support HTTP/1.1).",
          "createdAt": "2021-07-27T10:36:27Z",
          "updatedAt": "2021-07-27T10:37:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "I keep forgetting that I wrote RFC 7639. Still, I agree on all counts. ALPN has a purpose, but it isn't quite right here. Update tokens are a little weird, but I think that they are actually perfect. We just need to reclaim them for use.",
          "createdAt": "2021-07-27T12:01:18Z",
          "updatedAt": "2021-07-27T12:01:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing I do find appealing about using Upgrade Tokens is that it means that HTTP/1.1 support becomes easy: we just use Upgrade and keep the target in the path like in h2 and h3. And conceptually an upgrade is what we're doing: we're replacing the DATA stream with a new protocol that uses capsules/stream chunks. That's not too dissimilar to WebSocket.",
          "createdAt": "2021-07-27T16:14:40Z",
          "updatedAt": "2021-07-27T16:14:40Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU3NjU3NjgxMjY=",
      "title": "CONNECT-UDP Stream Chunk extensibility",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/24",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/draft-ietf-masque-connect-udp-01#section-5 defines Stream Chunk and follows up with a statement about extensibility\r\n\r\n```\r\nCONNECT-UDP Stream Chunk {\r\n     CONNECT-UDP Stream Chunk Type (i) = 0x00,\r\n     UDP Payload Length (i),\r\n     UDP Payload (..),\r\n   }\r\n\r\n<snip/>\r\n\r\n   The bidirectional stream that the CONNECT-UDP request was sent on is\r\n   a sequence of CONNECT-UDP Stream Chunks.  The CONNECT-UDP Stream\r\n   Chunk Type is designed to allow future extensibility.  Endpoints that\r\n   receive a chunk with an unknown CONNECT-UDP Stream Chunk Type MUST\r\n   silently skip over that chunk.\r\n```\r\n\r\nIt isn't clear to me if the `UDP Payload Length` field belongs solely to type `0x00` or if its expected to be the chunk length and applicable to all Chunk Types that are known or unknown. If the chunk length in *not*common to all chunks, I don't see how an endpoint can silently skip unknown chunks.\r\n",
      "createdAt": "2020-12-14T01:42:55Z",
      "updatedAt": "2020-12-30T17:10:30Z",
      "closedAt": "2020-12-30T17:10:30Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "You're absolutely right, that text is not very well written. What I meant to say is that the type and length are generic and the value depends on the type - and if the type is 0x00 then the value is a UDP payload. I'll fix the text.",
          "createdAt": "2020-12-14T01:56:30Z",
          "updatedAt": "2020-12-14T01:56:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I fixed the text in [draft-ietf-masque-connect-udp-02](https://tools.ietf.org/html/draft-ietf-masque-connect-udp-02), closing.",
          "createdAt": "2020-12-30T17:10:30Z",
          "updatedAt": "2020-12-30T17:10:30Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU3Njc2NDYzNDY=",
      "title": "Recovery consideration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/25",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The new draft version says:\r\n\r\n```\r\n   When the protocol running over UDP that is being proxied uses loss\r\n   recovery (e.g., [QUIC]), and the underlying HTTP connection runs over\r\n   TCP, the proxied traffic will incur at least two nested loss recovery\r\n   mechanisms.  This can reduce performance as both can sometimes\r\n   independently retransmit the same data.  To avoid this, HTTP/3\r\n   datagrams SHOULD be used.\r\n```\r\n\r\nI think this text it to general. The problem only occurs if both control loop act on the same time scale. If the outer control however, has a much short delay than the e2e connection, losses will be retransmitted locally and not detected as loss by the e2e connection. As such this would translate local losses into delay variation. As long as these delay variation are small it can actually benefit performance.\r\n\r\n",
      "createdAt": "2020-12-15T14:23:45Z",
      "updatedAt": "2020-12-15T17:38:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@mirjak can you send a PR with the text you have in mind?",
          "createdAt": "2020-12-15T17:38:09Z",
          "updatedAt": "2020-12-15T17:38:09Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3NjkxNjc4MDM=",
      "title": "IP assignment",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/26",
      "state": "OPEN",
      "author": "mirjak",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "The draft currently doesn't say anything/much (?) about IP address assignment. The client might need a way to request a certain IP address, request information about the used IP address, or request requirements/restriction on the IP address assignment by the proxy (e.g. stable IP address or address obfuscation).",
      "createdAt": "2020-12-16T18:21:34Z",
      "updatedAt": "2020-12-17T18:19:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "Further I think additional text is also needed on handling of incoming traffic from the target server. I assume that the proxy will map that traffic based on the 5-tuple to an active CONNECT-UDP session, therefore the proxy would need to control the client side's src port at least. I guess there are usually no specific requirements from the client on the selected source port but some discussion on this would be good in the draft.",
          "createdAt": "2020-12-16T18:28:33Z",
          "updatedAt": "2020-12-16T18:28:33Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds like something that could be handled by an extension. There's no need to discuss IP assignment in CONNECT-UDP just like there is no need to discuss it in CONNECT.\r\n\r\nRegarding https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/26#issuecomment-746781776, can you please send a PR with the text you have in mind?",
          "createdAt": "2020-12-17T17:39:06Z",
          "updatedAt": "2020-12-17T17:39:06Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I was looking for something like section 2.1 in the quic proxying draft: https://www.ietf.org/archive/id/draft-pauly-masque-quic-proxy-00.html#name-datagram-flow-id-mapping",
          "createdAt": "2020-12-17T18:14:56Z",
          "updatedAt": "2020-12-17T18:14:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds great, can you send a PR?",
          "createdAt": "2020-12-17T18:19:48Z",
          "updatedAt": "2020-12-17T18:19:48Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU3ODExODc3Nzk=",
      "title": "multiplexing flows",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/27",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "QUIC allows a client to use a single UDP port to establish connections to an arbitrary number of servers. Packets are demultiplexed to their respective connections by their connection ID.\r\n\r\nIt would be nice if MASQUE allowed the proxy to do the same thing. To do so, the client could indicate that packets sent on flow M can be multiplexed on the same socket that flow N uses. The proxy would then be allowed to send all UDP packets it receives from the target on flow N.\r\n\r\nIs that something this document should specify, or would this better be moved to an extension?",
      "createdAt": "2021-01-07T10:00:38Z",
      "updatedAt": "2021-01-11T19:58:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "My personal preference would be to move this to an extension, since it's not required for CONNECT-UDP to work.",
          "createdAt": "2021-01-07T10:11:08Z",
          "updatedAt": "2021-01-07T10:11:08Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "@marten-seemann that sounds like it's in the scope of https://tfpauly.github.io/quic-proxy/draft-pauly-masque-quic-proxy.html",
          "createdAt": "2021-01-11T19:58:50Z",
          "updatedAt": "2021-01-11T19:58:50Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU3ODMwODUxMTg=",
      "title": "Are stream chunks HTTP/3 frames?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/28",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft is not clear if stream chunks are \r\n1. HTTP/3 frames (and as such serialized onto the QUIC stream directly), or \r\n2. if they're supposed to be sent as the payload of HTTP/3 DATA frames.\r\n\r\nI assume 1., and I'd be happy to come up with an editorial PR to clarify this.",
      "createdAt": "2021-01-11T05:50:33Z",
      "updatedAt": "2021-07-12T22:07:18Z",
      "closedAt": "2021-07-12T22:07:18Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Stream chunks are sent as the payload of h3 DATA frames, or the payload of h2 DATA frames, or directly in the TLS stream in HTTP/1.1. I'll clarify the text.",
          "createdAt": "2021-01-11T18:09:58Z",
          "updatedAt": "2021-01-11T18:09:58Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "> Stream chunks are sent as the payload of h3 DATA frames, or the payload of h2 DATA frames\r\n\r\nI'm sure you have a reason for this. Why don't we define a new frame type here? I realize that this means using a different serialization for H2 and H3, but this is something your HTTP stack would most likely know how to handle.",
          "createdAt": "2021-01-13T05:11:15Z",
          "updatedAt": "2021-01-13T05:11:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "What's the benefit of defining a new frame? CONNECT uses DATA frames; a departure from that would increase complexity.",
          "createdAt": "2021-01-13T16:33:34Z",
          "updatedAt": "2021-01-13T16:33:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events: stream chunks were removed in 649890881aaa92548b5a0fb37a7622b409b281fd. Closing.",
          "createdAt": "2021-07-12T22:07:18Z",
          "updatedAt": "2021-07-12T22:07:18Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU3ODM0NzM1NzA=",
      "title": "Tunneling of ECN Marks",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/29",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Even if CONNECT-UDP has no explicit ECN support without an extension, there is ambiguity relating to copying of ECN bits between 'inner' and 'outer' datagrams. MASQUE is not strictly IP-in-IP, though it's close to it, so it's not clear if RFC 6040 applies.  Nevertheless, I would propose the following principles:\r\n\r\n- ECN markings on the MASQUE connection SHOULD NOT be copied to any resulting UDP datagrams sent by the proxy; they should apply to the MASQUE connection only. If MASQUE congestion control is disabled per section 9, it MUST mark all packets non-ECT.\r\n- ECN markings on incoming UDP datagrams SHOULD NOT be copied to the IP headers of MASQUE packets that encapsulate them: upstream congestion should not affect the congestion state of the MASQUE connection.\r\n\r\nI'm happy to write a PR to that effect.",
      "createdAt": "2021-01-11T15:36:39Z",
      "updatedAt": "2021-03-05T22:43:06Z",
      "closedAt": "2021-03-05T22:43:06Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "When using CONNECT-UDP without extensions, the server-facing UDP sockets on the proxy will not be configured to use ECN, so there will not be any ECN markings on the proxy-server path. In other words, ECN will not be in use, so do we need text about it? Adding text to clarify this sounds reasonable, but it probably should be generic to anything in the IP header.",
          "createdAt": "2021-01-11T18:42:25Z",
          "updatedAt": "2021-01-11T18:42:25Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The extensions explicitly concern markings on DATAGRAM frames in the inner connection. The server may very well be sending packets with ECT(0). With no extension, it will eventually stop, but nevertheless these shouldn\u2019t appear in MASQUE IP headers.",
          "createdAt": "2021-01-11T19:07:01Z",
          "updatedAt": "2021-01-11T19:07:01Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. I'll take you up on your offer to write a PR then :)",
          "createdAt": "2021-01-11T19:17:07Z",
          "updatedAt": "2021-01-11T19:17:07Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "Yes, I think that being clear that for this case the two legs needs to be kept seperate unless internal signalling is used on client to proxy leg to influence the external side setting and receiving of these values. ",
          "createdAt": "2021-01-12T10:47:21Z",
          "updatedAt": "2021-01-12T10:47:21Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU3ODQxMjc0Mzc=",
      "title": "Use Behave defined UDP timeouts as default minimal times for recovering unused flows",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/31",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "RFC 4787 (https://datatracker.ietf.org/doc/rfc4787/) does define some default timeouts for NAT bindings for UDP. Over general Internet I would not expect that UDP flow state is mainstained longer than these default values. Thus, I think it makes sense to indicate that if the MASQUE server is recovering state for inactive UDP flows, it SHOULD NOT recover them faster than the timeout recommendation in the behave UDP RFC. ",
      "createdAt": "2021-01-12T10:52:49Z",
      "updatedAt": "2021-10-06T22:24:36Z",
      "closedAt": "2021-10-06T22:24:36Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That makes sense to me, can you send a PR? Otherwise I'll add it in the next batch.",
          "createdAt": "2021-01-12T15:52:20Z",
          "updatedAt": "2021-01-12T15:52:20Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU3ODQyMDc4NTg=",
      "title": "Next hop MASQUE proxy identity",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/32",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "So I think there are two different cases how chaining of MASQUE proxies may occurr.\r\n\r\nHop-by-hop: To my understanding is that this can occur when one masque proxy makes a decision based on either explicit signalling (would be extension) or an internal policy to forward the MASQUE proxying request to the next MASQUE server. So this can be done hiddenly from the client by the first one as part of an internal infrastructure from the MASQUE server provider, or it could be done towards an external one. For the later I think there exist the question if there should be any control over this. In RTSP 2.0 there exists a mechanism in Section  19.3 of RFC 7826 (https://www.rfc-editor.org/rfc/rfc7826.html#section-19.3) that enables the client to determine the identity of the next hop proxy. I don't know if this is needed for this, but I wanted to bring it up.\r\n\r\nOnion routing: Where the client will use the first proxy to establish a UDP flow to the next masque proxy and then establish a HTTP/3 connection to that one to identify it explictly and then request one additional proxy flow. \r\n\r\nMy main point to bring up this is the question if the models and how they work under HTTP provides the sequerity one would expect or if we simply need to note that the masque client is trusting that first proxy to establish that proxied flow and that is it. If it wants more control over any multi-hop then it needs to take the overhead of onion routing?\r\n\r\n",
      "createdAt": "2021-01-12T12:51:23Z",
      "updatedAt": "2021-03-05T22:45:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you have a use-case where a client would want this level of control but where onion routing isn't the right solution?",
          "createdAt": "2021-01-12T15:55:00Z",
          "updatedAt": "2021-01-12T15:55:00Z"
        },
        {
          "author": "sysrqb",
          "authorAssociation": "NONE",
          "body": "> Do you have a use-case where a client would want this level of control but where onion routing isn't the right solution?\r\n\r\nNested QUIC connections impose the addition TLS handshake overhead, and wasted space due to nested headers. A variant of QUIC-Aware Proxying (https://datatracker.ietf.org/doc/html/draft-pauly-masque-quic-proxy-00) seems like a good starting point for reducing the header overhead.\r\n\r\n`Accept-Credentials` is a good foundation for validating that the connection was correctly extended to a specific proxy, but its lacking a means of establishing shared cryptographic keys between the client and the (new) end proxy. A MASQUE extension should account for this.\r\n\r\nI realize traffic analysis is considered outside the scope of MASQUE, but I'll quickly venture down that path anyway in case it's helpful. As I understand it, onion routing, as created by nested QUIC/TLS sessions, results in distinct connections IDs for every client. In multi-proxy onion routing this means that a network observer somewhere along the path can create precise profiles of that client's behavior and traffic patterns over time, even if they may not know the IP address of the client. This leakage may negate some of the benefits of using multiple proxies, depending on how the proxies are selected. With hop-by-hop, a proxy can coalesce client connections onto a single connection, and that multiplexing reduces this leakage.",
          "createdAt": "2021-02-10T04:37:16Z",
          "updatedAt": "2021-02-10T04:37:16Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU3ODQyMTA4ODY=",
      "title": "MASQUE scheme registration needs its own section or possibly document",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/33",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "So the URI scheme registration rules (https://datatracker.ietf.org/doc/rfc7595/) have a number of things to consider. Thus, at a minimal the definition needs its own section where that is properly covered. My experience is that the template and definition needs its own sections to make it easy to define clearly and know where things reside. \r\n\r\nI would also note that issue #23 depending on the semantics is for masque scheme and how it relates to the proxied protocol it might make sense to split this scheme out into its own document even if it will be a short one.\r\n",
      "createdAt": "2021-01-12T12:55:54Z",
      "updatedAt": "2021-09-11T16:19:14Z",
      "closedAt": "2021-09-11T16:19:14Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or, better yet, we don't define any scheme, and just use https for the CONNECT-UDP requests!",
          "createdAt": "2021-03-05T16:13:19Z",
          "updatedAt": "2021-03-05T16:13:19Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU3ODQyMTI0MTU=",
      "title": "Should datagram extension be RECOMMENDED",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/34",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I understand that we can't require datagram support as we need fallback to other HTTP versions. However, can we at least RECOMMEND datagram be implemented?\r\n\r\n",
      "createdAt": "2021-01-12T12:58:05Z",
      "updatedAt": "2021-07-12T22:08:05Z",
      "closedAt": "2021-07-12T22:08:05Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought that this was clear implicitly, but we could make it explicit - can you send a PR?",
          "createdAt": "2021-01-12T15:56:12Z",
          "updatedAt": "2021-01-12T15:56:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events: we now have a dependency on HTTP Datagrams since 649890881aaa92548b5a0fb37a7622b409b281fd. Closing.",
          "createdAt": "2021-07-12T22:08:05Z",
          "updatedAt": "2021-07-12T22:08:05Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU3ODQzNzE5MDk=",
      "title": "What to do with UDP server ports?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/35",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "extension"
      ],
      "body": "So far we Connect-UDP only supports bi-directional UDP flows initiated by the masque client. A substantial question is if we are planning for supporting a UDP server port on the MASQUE proxy. I have seen a couple of references to the need for this. I think there are several needs for this that at least indicate that we should discuss this properly and its design implications.\r\n\r\n1. ICE based establishment procedures works better if the port can accept from unknown sources.\r\n2. Running QUIC servers behind MASQUE proxy\r\n3. Running multiparty services or servers in general\r\n\r\nSo why I think this is a design issue is that the solution can interact significantly with other aspects of the protocol. One potential solution here which would re-use the basic mechanism is basically to use a proxy to client asynchronous message to indicate and initiate the establishment of an additional UDP flow to receive the remaining traffic.  That same mechanism is also a solution to some other issues like ICMP message handling. So I think there is a point to think through the various extensions and consider how protocol mechanism can be reused for multiple extensions and what is truly the core mechanisms of the protocol.\r\n\r\n",
      "createdAt": "2021-01-12T16:05:56Z",
      "updatedAt": "2021-07-23T18:54:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this use-case would be well served by an extension to CONNECT-UDP.",
          "createdAt": "2021-03-05T22:47:19Z",
          "updatedAt": "2021-03-05T22:47:19Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Such an extension should also inform the client of the IP and port that have been allocated to it.",
          "createdAt": "2021-07-23T18:54:22Z",
          "updatedAt": "2021-07-23T18:54:22Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU3ODQ2MzA5NTA=",
      "title": "No CONNECT-UDP Stream Chunk Types are defined",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/36",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft is not implementable as a result.  Or maybe it is not very useful.  Presumably we need a type defined to carry UDP packets.",
      "createdAt": "2021-01-12T22:11:52Z",
      "updatedAt": "2021-01-12T22:26:43Z",
      "closedAt": "2021-01-12T22:26:43Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft defines 0 for this purpose in [section 6](https://tools.ietf.org/html/draft-ietf-masque-connect-udp-03#section-6). Do you have something else in mind?",
          "createdAt": "2021-01-12T22:22:06Z",
          "updatedAt": "2021-01-12T22:22:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "My bad, I completely missed that.  Easy to read past that section.",
          "createdAt": "2021-01-12T22:26:43Z",
          "updatedAt": "2021-01-12T22:26:43Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU3ODQ2MzI2Mjk=",
      "title": "Datagram-Flow-Id header or just use a Chunk type?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/37",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft currently recommends use of a header to allocate datagram flow ids.  But it could equally use chunks to add these.  That might be a way to avoid over-allocation in the case that you need multiple flows.  Rather than allocating all the flows up front, they could be added as necessary.",
      "createdAt": "2021-01-12T22:14:10Z",
      "updatedAt": "2021-07-12T22:08:23Z",
      "closedAt": "2021-07-12T22:08:23Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "@LPardue noted in the call today that intermediaries might want access to this information, so maybe frames (at the HTTP/2 or HTTP/3 layer) are better than chunks or headers.",
          "createdAt": "2021-01-12T22:54:52Z",
          "updatedAt": "2021-01-12T22:54:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "@martinthomson What's an example of over-allocation in the current header scheme?\r\n\r\nGiven that the method should work across any HTTP version, I think making the flow ID header work the same across datagrams and stream chunks (as proposed in #38) would allow intermediaries to correctly translate, if necessary.",
          "createdAt": "2021-01-13T17:41:59Z",
          "updatedAt": "2021-01-13T17:41:59Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Let's say that you want to use flow identifiers to encode ECN markings.  Do you allocate all 4 flow identifiers to represent all possible options?  What if you never intend to use ECT1?  Are you allocating ECT1 on the off-chance that a packet arrives with that marking?\r\n\r\nBasically, with the proposed ECN compression scheme, this results in a fixed commitment for every session.  However, if it were possible to signal additional mappings after establishing a flow, then you could add them just in time.  That has some race condition issues, but that could be resolved with buffering of various sorts and so it still might be preferable to having to know at the time you set things up what flows you need.\r\n\r\nThink about the potential use of flows to map to connection IDs for relaying QUIC.",
          "createdAt": "2021-01-13T22:25:52Z",
          "updatedAt": "2021-01-13T22:25:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "I think the argument that we're wasting flow IDs if we're reserving the numbers up front isn't particularly compelling given how large the space of IDs is, and that there isn't any need to actually allocate memory or state tracking for the ID values.\r\n\r\nHowever, I do appreciate that being able to have flexible bindings allows us to do more dynamic things, particularly since for things like QUIC connection IDs, they can come and go more frequently.\r\n\r\nHow would the use of frames work?",
          "createdAt": "2021-01-14T00:50:30Z",
          "updatedAt": "2021-01-14T00:50:30Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "We define a new frame type that carries the same information the header field does.  Use that frame to map flows to the request stream and attach any semantics you like to them.  It would likely require a setting to work properly.",
          "createdAt": "2021-01-14T01:17:40Z",
          "updatedAt": "2021-01-14T01:17:40Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "This sounds a bit like how PRIORITY_UPDATE is intended to work, it carries the same encoded values as the Priority header. We chose to restrict that to the control stream (or stream 0) because conventional requests close the stream in the send direction. CONNECT-* streams are by definition different because the stream remains open. I",
          "createdAt": "2021-01-14T01:28:26Z",
          "updatedAt": "2021-01-14T01:28:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events: Datagram-Flow-Id was removed in 649890881aaa92548b5a0fb37a7622b409b281fd. Closing.",
          "createdAt": "2021-07-12T22:08:23Z",
          "updatedAt": "2021-07-12T22:08:23Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU3ODUzMDE5ODk=",
      "title": "Consider using the Flow ID as stream chunk ID instead of having chunk types",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/38",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, using CONNECT-UDP over DATAGRAMs and over HTTP streams use entirely different mechanisms for identifying data:\r\n\r\n- DATAGRAMS use a Datagram Flow ID, which allows the request headers to define meanings and mappings\r\n- The fallback to stream case uses an IANA registry of chunk types\r\n\r\nI think we can simplify this by always using the Flow ID. The Flow ID can replace the \"type\" in the stream chunk, making the content of the chunks identical to DATAGRAM frames (length + flow ID + payload).",
      "createdAt": "2021-01-13T17:35:26Z",
      "updatedAt": "2021-07-12T22:08:49Z",
      "closedAt": "2021-07-12T22:08:49Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I guess alternatively you could add the chunk type to the datagram (instead of overloading the flow ID). That consumes a few more bits but maybe also gives more flexibility.",
          "createdAt": "2021-01-18T09:55:31Z",
          "updatedAt": "2021-01-18T09:55:31Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "@mirjak the way I view it, the flow ID is an arbitrary varint field, and the chunk type is too; having two arbitrary fields doesn't seem to be useful?",
          "createdAt": "2021-01-23T00:45:42Z",
          "updatedAt": "2021-01-23T00:45:42Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "It's two type fields in two different protocols (H3 and Masque). In that sense it's cleaner to separate them. Depends on how urgently we want to save bits.",
          "createdAt": "2021-01-25T10:51:38Z",
          "updatedAt": "2021-01-25T10:51:38Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "The flow ID for H3 doesn't have meaning in and of itself beyond demulitplexing\u2014but MASQUE can bring meaning to it.\r\n\r\nSince the current draft presents the stream-chunk approach as a compatibility mechanism for H2 or H1, I view it as something trying to provide the semantics of H3 datagrams for older versions. To that end, my proposal is to make that very explicit and define that for H2 and H1, they can express datagram semantics over streams using the same identifiers as H3.",
          "createdAt": "2021-01-25T15:30:51Z",
          "updatedAt": "2021-01-25T15:30:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "How would this proposal work when datagrams are disabled (or with HTTP/2)?",
          "createdAt": "2021-03-06T21:54:51Z",
          "updatedAt": "2021-03-06T21:54:51Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "The flow ID is completely determined by the HTTP layer, and isn't really specific to the use of datagrams--it's just an identifier for a set of messages. The fact that those messages get encoded over QUIC datagrams is a wire image detail, and it seems reasonable to map those when in cases where the wire image is over a stream. ",
          "createdAt": "2021-03-07T02:47:10Z",
          "updatedAt": "2021-03-07T02:47:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Right now we use the \"Datagram-Flow-Id\" header to negotiate datagram support, so we'd need a different mechanism for that. That increase in complexity might outweigh the simplicity benefits of unifying chunk IDs and flow IDs.",
          "createdAt": "2021-03-07T21:36:48Z",
          "updatedAt": "2021-03-07T21:36:48Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi Doesn't the settings parameter determine if datagrams are supported? My assumption would be that if you send the flow ID without supporting datagrams, you need to encode them in the stream. \n\nI really think that a separate registry of types just for the fallback case of no datagrams seems very awkward, and I don't see yet why it is necessary. ",
          "createdAt": "2021-03-07T22:37:11Z",
          "updatedAt": "2021-03-07T22:37:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "To me it seems that there are two things being discussed here:\r\n* if chunk ID of a stream chunk indicates the type of data being sent, or if it is just an identifier of a flow\r\n* if the chunk ID field can be replaced by an identifier of a flow, reusing the definition of H3_DATAGRAM\r\n\r\nTo me it seems that the latter would only be sensible when we agree that the chunk ID field of a stream chunk is just an identifier, rather than something that indicates a type. Are we agreeing on that? If so, I think we can agree that there's no need for an IANA registry.\r\n\r\nAssuming that we'd agree on that, the question becomes if calling both of the two \"datagram flow IDs\" makes sense. I do not have a strong opinion, though I'd point out that the scope of the identifier is going to be different for stream chunks and H3_DATAGRAM frames. For the former, the scope would be per-HTTP-stream, whereas for the latter the scope is per-HTTP-connection. Therefore, I can see some raising concern of calling things the same that would not be used interchangeably.",
          "createdAt": "2021-03-07T23:23:35Z",
          "updatedAt": "2021-03-07T23:24:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@tfpauly that's not quite how that works in the presence of HTTP intermediaries, the SETTING only tells you if datagrams are supported in general, but you also need to know if they're supported for this specific request - as an intermediary might want to support datagrams only to certain backends. So, as @kazuho was saying, per-connection vs per-stream.",
          "createdAt": "2021-03-08T12:25:52Z",
          "updatedAt": "2021-03-08T12:25:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Ah, yes, quite right. The settings lets you know if the connection you're on supports datagrams.\r\n\r\nIf the intermediary did support datagrams, however, could it not translate those into stream chunks if it couldn't speak datagrams upstream (assuming we shared ID space)? If there is a deterministic translation, I could still get the benefit of datagrams between the client and intermediary, which often might be the hop where it matters most.",
          "createdAt": "2021-03-08T14:10:06Z",
          "updatedAt": "2021-03-08T14:10:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "An intermediary could definitely do that, but the current design doesn't require all intermediaries to implement this, so this would increase intermediary implementation complexity",
          "createdAt": "2021-03-08T14:34:42Z",
          "updatedAt": "2021-03-08T14:34:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Could we require intermediaries to do this if they support the SETTINGS option, and allow upstreams to servers that don't support datagrams?",
          "createdAt": "2021-03-08T14:45:11Z",
          "updatedAt": "2021-03-08T14:45:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "We could, but why are we doing this in the first place? I thought the argument was simplicity",
          "createdAt": "2021-03-08T14:55:20Z",
          "updatedAt": "2021-03-08T14:55:20Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "I'm going for simplicity in the spec, simplicity for designing extensions, and simplicity for endpoints that are deployed in the most common cases.\r\n\r\nCurrently, the registry of chunk types is only relevant to implementations when they're falling back to cases where datagrams aren't supported. This means that all implementations\u2014clients, servers, and intermediaries\u2014need to maintain separate logic for how messages are mapped. Also, if I want to write an extension (let's say, to do ECN), I'll need to define how to encode the meaning of my datagrams via flow IDs _and_ entirely separately define chunk types for the meanings of different chunks.\r\n\r\nAt the end of the day, the information being communicated should be isomorphic between datagrams and stream chunks; so, it should be possible to represent the types of messages with (at least) isomorphic identifiers, if not exactly the same identifiers. It seems very odd that one is negotiated through headers dynamically and the other has an IANA registry.\r\n\r\nNow, given that I'm not an intermediary implementor, I may not be understanding the complexity correctly, but it seems to me that the system is overall simpler and more efficient if the layer that is aware of translation already is the one that is responsible for mapping between datagrams and stream chunks, and can do it with consistent identifiers. This means a client or end server would only need to do one-or-the-other on a connection, not a mix of both.\r\n\r\nIf I'm a client, and my connection's server says it supports datagrams, I'm going to prefer to send a DATAGRAM frame right after my CONNECT-UDP request to avoid an extra round trip. If the server is an intermediary whose upstream doesn't support datagrams, I'd rather it either (a) not advertise datagram support in its own SETTINGS (which is easy for the intermediary, and means the client can start sending stream chunks right away), or (b) do the deterministic translation into stream chunks (and get the benefit of being able to use datagrams on the hop between the client and intermediary). Currently, it would (c) receive the client's datagram, but drop it on the floor, and send a response back to tell the client to send the same message again over the stream. This seems to be more complex to me, overall; and certainly less optimal.",
          "createdAt": "2021-03-08T16:15:57Z",
          "updatedAt": "2021-03-08T16:15:57Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "@tfpauly I would point out that there's at least one difference other than flow IDs vs. chunks, and that is negotiation. I would not be surprised if the difference becomes a headache in designing extensions.\r\n\r\nUsing ECN as an example, I'd assume that the ECN signal will be conveyed by a different flow, designated using a parameter of the datagram-flow-id header field, e.g.,`datagram-flow-id: 0; ecn=2`.\r\n\r\nThe exchange of the header field serves two purposes; 1) negotiation of the features to be used, 2) dynamic mapping between flow IDs and types.\r\n\r\nBecause use of ECN is negotiated using the header fields, we can send ECN-marked datagrams using flow ID 2, while sending non-marked datagrams using ID 0.\r\n\r\nBut in case of stream chunks, there is no negotiation. Stream chunks carrying unknown ID are simply discarded. Therefore, even if we define a stream chunk type for ECN, that type cannot carry the payload of ECN-marked datagrams. We have to define a way to split ECN signal and datagram payload, and send them separately.\r\n\r\nTo summarize, to me it seems that the debate is between:\r\n* Proposed change) For both stream chunks and H3_DATAGRAM, use flow IDs, use dynamic mapping, with negotiation. Features are named by the header fields.\r\n* Status quo) For stream chunks continue using static mapping without negotiation. Features are identified by stream chunk types.\r\n\r\nAm I reading correctly?",
          "createdAt": "2021-03-09T00:00:23Z",
          "updatedAt": "2021-03-09T00:00:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Yes, my proposal is that the stream chunks are negotiated exactly the same as datagram flow identifiers. Effectively, they become message flow identifiers, where the messages can be sent over LV stream chunks or LV datagram frames. They could use the same headers to negotiate, and key only off of settings to know which to use for a given hop. ",
          "createdAt": "2021-03-09T01:14:53Z",
          "updatedAt": "2021-03-09T01:14:53Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "@tfpauly Thank you for the clarification. If we are to take that route (of negotiating features), I would be supportive to adopting the proposed change. The benefit of having one negotiation mechanism outweighs the cost of having to map types dynamically when only using stream chunks.",
          "createdAt": "2021-03-09T02:14:54Z",
          "updatedAt": "2021-03-09T02:14:54Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "+1 to basically use the same negotiation mechanism and therefore make fallback to streams easy. I also think that using datagram where possible and potentially \"translate\" at the intermedia is a good thing. I think still we might have two different pieces of information here, the flow/stream ID and some kind of chunk/message header. I think keeping these things separate makes the protocol more flexible (even though that might cost a few more bits which however its probably only rally a problem for datagrams but not so much for streams).",
          "createdAt": "2021-03-09T14:20:49Z",
          "updatedAt": "2021-03-09T14:20:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@tfpauly I don't understand how this negotiation would work. Could you please write up an example of what the HTTP headers on request and response would look like? Note that this needs to support optional negotiation of datagram support, and needs to work in the presence of intermediaries.",
          "createdAt": "2021-03-09T19:50:32Z",
          "updatedAt": "2021-03-09T19:50:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Yes, it's quite simple:\r\n\r\nServer supports datagrams:\r\n--> SETTINGS(H3_DATAGRAMS)\r\n<-- SETTINGS(H3_DATAGRAMS)\r\n--> HEADERS(CONNECT-UDP, datagram-flow-id: 2)\r\n<-- HEADERS(CONNECT-UDP, datagram-flow-id: 2)\r\n--> DATAGRAM(id=2, body)\r\n<-- DATAGRAM(id=2, body)\r\n\r\nServer doesn't support datagrams:\r\n--> SETTINGS(H3_DATAGRAMS)\r\n<-- SETTINGS()\r\n--> HEADERS(CONNECT-UDP, datagram-flow-id: 2)\r\n<-- HEADERS(CONNECT-UDP, datagram-flow-id: 2)\r\n--> DATA(length=N,id=2, body)\r\n<-- DATA(length=M,id=2, body)\r\n\r\nAnd if intermediaries want to talk datagrams to clients but the upstream server doesn't, they just stuff DATAGRAMS over DATA frame chunks and vice versa.\r\n\r\nThe only thing you don't have here is the ability to have a request-by-request ability to choose if it should send CONNECT-UDP messages over DATAGRAM frames or DATA frame chunks. However, I don't see how that is important.",
          "createdAt": "2021-03-09T19:55:54Z",
          "updatedAt": "2021-03-09T19:55:54Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "Okay, spoke in gather town... proposal would be to keep stream chunks, but when you have a data type of chunk, you still include the flow ID always. Make it clear that you can have other stream chunk types even when supporting datagrams as a way to support reliable control messages associated with the request.\r\n\r\nThis way the stream chunk data content is always isomorphic to datagram payloads. This does allows intermediaries to map between datagram and chunks without loss of data.",
          "createdAt": "2021-03-09T20:28:27Z",
          "updatedAt": "2021-03-09T20:28:27Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "NONE",
          "body": "And you'd have to reset the stream if you receive a stream chunk datagram ID that isn't defined for this stream.",
          "createdAt": "2021-03-09T21:03:23Z",
          "updatedAt": "2021-03-09T21:03:23Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "I might want to push back a bit on going back to status quo, in particular as an argument for having a unified negotiation scheme.\r\n\r\nI think that there might a subtle error in @tfpauly's example, but I think that the concept is visible. Use one mechanism that maps types to flow IDs, and use one flow ID in both H3_DATAGRAM frames and stream chunks to indicate the type of data being sent. We can have a separate signal (e.g., a header field) indicating if H3_DATAGRAMs can be used on a particular stream.\r\n\r\nTo give an example, if the peers ended up negotiating `datagram-flow-id: 2, 4=timestamp`, flow ID of 2 would indicate that the payload is a datagram without timestamp, and that flow ID of 4 would indicate that the payload is a datagram with a timestamp, regardless of the payload being carried by a H3_DATAGRAM frame or as a stream chunk.\r\n\r\nI think there's appetite among us to have a negotiation mechanism that is isomorphic.\r\n\r\nHowever, there's one problem, and that is the \"datagram-flow-id\" header field. The field is defined as a way to communicate the use of H3_DATAGRAM frame, instead of a way of communicating how the CONNECT-UDP method would convey data regardless of the conveyor being H3_DATAGRAM frame or a stream chunk.\r\n\r\nI think that might be the crux of the problem.\r\n\r\nDo we want have two negotiation methods for CONNECT-UDP, one that negotiates the use of H3_DATAGRAM frames using the \"datagram-flow-id\" header field, as well as defining a scheme to negotiate the types to be used for stream chunks? Or do we want to create an isomorphic negotiation scheme for CONNECT-UDP, that designates IDs for both H3_DATAGRAM flows and stream chunk flows?\r\n\r\nATM my preference goes to the latter.\r\n\r\nHonestly, I'm not sure if I like the current approach being taken in H3_DATAGRAM, of designing `datagram-flow-id` header field as the only way to negotiate how flows are to be used. The scheme being discussed is complex, and it could be the case that the complexity roots from the fact that the scheme has to cover all use cases including the ones that we might see in the future.\r\n\r\nWe could take a different path, allowing each application of H3_DATAGRAM to designate the flow IDs that it would use in its own way. If we take that path, masque can name the flow IDs isomorphically, in a simple manner.",
          "createdAt": "2021-03-09T23:32:19Z",
          "updatedAt": "2021-03-09T23:32:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "> Honestly, I'm not sure if I like the current approach being taken in H3_DATAGRAM, of designing datagram-flow-id header field as the only way to negotiate how flows are to be used. The scheme being discussed is complex, and it could be the case that the complexity roots from the fact that the scheme has to cover all use cases including the ones that we might see in the future.\r\n\r\n> We could take a different path, allowing each application of H3_DATAGRAM to designate the flow IDs that it would use in its own way. If we take that path, masque can name the flow IDs isomorphically, in a simple manner.\r\n\r\nI think that's a fair observation but during the \"dispatching\" of the H3_DATAGRAM draft to a working group, there were some strong opinions against defining a generic HTTP/3 mechanism that was not tied to any semantic. The header is a binding. It could be substituted if someone wanted to (and they could probably gain a lot of inspiration from the text that we'll have on allocating and managing flow IDs.)\r\n\r\nThat said, I think I agree with your observation:\r\n\r\n> The field is defined as a way to communicate the use of H3_DATAGRAM frame, instead of a way of communicating how the CONNECT-UDP method would convey data regardless of the conveyor being H3_DATAGRAM frame or a stream chunk.\r\n\r\nThere's a subtlety between these two that I think is easily missed and contributing some of the difficulty in discussion.",
          "createdAt": "2021-03-09T23:44:22Z",
          "updatedAt": "2021-03-09T23:44:22Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "@LPardue Thank you for sharing the history.\r\n\r\nOne way of moving forward without revisiting the decision that have been made during dispatching would be to split the negotiation of the flows being used and _how_ they are being used. We could continue using `datagram-flow-id` header field to name the flow IDs that we'd use for H3_DATAGRAM frames, but there's no reason to use the same header field for expressing how each of the flow is going to be used by CONNECT-UDP.\r\n\r\nThat said, I tend to wonder if trying to use multiple flow IDs on a single CONNECT-UDP stream is worth the effort, when the benefit is saving like one byte per datagram. As @mirjak pointed out [far above](https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/38#issuecomment-762131025), we could add a type field to the payload of H3_DATAGRAM frames used for CONNECT-UDP streams. Then, negotiation of how types are going to be used becomes an issue specific to CONNECT-UDP.",
          "createdAt": "2021-03-10T00:17:12Z",
          "updatedAt": "2021-03-10T03:00:53Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events: flow IDs were removed in 649890881aaa92548b5a0fb37a7622b409b281fd. Closing.",
          "createdAt": "2021-07-12T22:08:49Z",
          "updatedAt": "2021-07-12T22:08:49Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU4MDE1ODQ1NTk=",
      "title": "Encoding of stream chunks on connected streams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/39",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The text says this about the encoding of stream chunks:\r\n\r\n> The bidirectional stream that the CONNECT-UDP request was sent on is a sequence of CONNECT-UDP Stream Chunks....\r\n\r\nIt's not clearly stated whether HTTP/3 frames stop being used and these stream chunks are written directly into the QUIC stream, or if Stream Chunks are the payload of HTTP/3 DATA frames which are then written into the QUIC stream, or if Stream Chunks are a new HTTP/3 frame type being defined.\r\n\r\nCONNECT uses DATA frames, saying this:\r\n\r\n> All DATA frames on the stream correspond to data sent or received on the TCP connection. The payload of any DATA frame sent by the client is transmitted by the proxy to the TCP server; data received from the TCP server is packaged into DATA frames by the proxy. Note that the size and number of TCP segments is not guaranteed to map predictably to the size and number of HTTP DATA or QUIC STREAM frames.\r\n\r\nGiven that support for CONNECT-UDP is not negotiated *a priori*, I think using DATA frames is the only sensible answer in the current state of the text, but the draft doesn't say that clearly.  New HTTP/2 and HTTP/3 frame types for Stream Chunks would also be a viable design that reduces framing overhead, but that's clearly not what the draft currently envisions, since no frame type is registered or defined.",
      "createdAt": "2021-02-04T19:47:16Z",
      "updatedAt": "2021-07-12T22:09:01Z",
      "closedAt": "2021-07-12T22:09:00Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the intent of the draft as currently written was to use DATA frames in the same way CONNECT does. We can clarify that.",
          "createdAt": "2021-02-04T20:06:49Z",
          "updatedAt": "2021-02-04T20:06:49Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "So what's the trade-offs of using new frames types vs this entirely new stream chunks?",
          "createdAt": "2021-04-15T18:17:03Z",
          "updatedAt": "2021-04-15T18:17:03Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Intermediaries, mostly.  Putting chunks in the DATA payload means only the host processing the \"request\" has to deal with them.  A new frame type means any intermediary needs to understand them at least enough to relay them.  While I find the idea of an intermediary that processes frames but doesn't process HTTP to be questionable, this appeared to be an implicit assumption in several of the discussions yesterday.\r\n\r\nIf there is no such intermediary, I think a frame type would probably be a cleaner way to spell this, but it's largely a bikeshed.",
          "createdAt": "2021-04-16T14:15:07Z",
          "updatedAt": "2021-04-16T14:15:07Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events: stream chunks were removed in 649890881aaa92548b5a0fb37a7622b409b281fd. Closing.",
          "createdAt": "2021-07-12T22:09:00Z",
          "updatedAt": "2021-07-12T22:09:00Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU4MDg2NTU3MjM=",
      "title": "Provide advice about proxies receiving UDP packets that won't fit in datagrams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/40",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A proxy can receive a UDP packet from an origin to a client that cannot fit within a DATAGRAM frame, given either the limit set by the maximum datagram frame size, or based on the current path MTU.\r\n\r\nIn this case, one solution is for the proxy to generate ICMP errors back to the sender. If that sender implements PMTU discovery, it should adjust its size.",
      "createdAt": "2021-02-15T16:03:09Z",
      "updatedAt": "2021-10-06T22:14:07Z",
      "closedAt": "2021-10-06T22:14:07Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think adding advice here is good, though we can't mandate sending ICMP because most OSes don't let user space applications send ICMP.",
          "createdAt": "2021-02-16T01:04:23Z",
          "updatedAt": "2021-02-16T01:04:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, we can't mandate it, but we should recommend it I think. For a full-blown production server, it should be possible.",
          "createdAt": "2021-02-16T01:12:45Z",
          "updatedAt": "2021-02-16T01:12:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Recommendation seems sensible. Although this does get me thinking about what the expectations of fragmentation are, we can't expect all UDP protocols to set DF.",
          "createdAt": "2021-02-16T01:41:26Z",
          "updatedAt": "2021-02-16T01:41:26Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "The DATAGRAM capsule type offers one way to address this.  Capsules can be arbitrarily large, because they'll be reassembled by QUIC.  If it won't fit in a QUIC DATAGRAM and you don't want to drop it, it goes in a DATAGRAM capsule.\r\n\r\nNow, that might not always be desirable, because capsules don't have all the behavior that causes you to choose datagrams in the first place; a proxy that behaves that way will mess with PMTUD, and in the degenerate case cause the server to select an MTU back to the client that _always_ gets encoded in capsules.\r\n\r\nPerhaps the client should be able to inform the server whether it prefers oversize messages to be tunneled or dropped?",
          "createdAt": "2021-07-23T18:49:04Z",
          "updatedAt": "2021-07-23T18:49:04Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU4MDk1Nzk3MTI=",
      "title": "Echoing \"Datagram-Flow-Id\" when the request is rejected",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/41",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There can be cases where a proxy detects a request that contains a \"Datagram-Flow-Id\" is otherwise rejected e.g. missing a mandatory field, contains an odd-numbered ID,  or perhaps the server just decides to return a 5xx. In such cases it is not clear if the proxy should echo the \"Datagram-Flow-Id\" or not. I don't have a strong preference either way but if its the proxy's choice, we might want to document this so that people don't make assumptions and get surprised.",
      "createdAt": "2021-02-16T19:17:30Z",
      "updatedAt": "2021-07-12T22:09:21Z",
      "closedAt": "2021-07-12T22:09:21Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, though we probably should mention this in draft-ietf-masque-h3-datagram rather than draft-ietf-masque-connect-udp?",
          "createdAt": "2021-02-16T19:34:37Z",
          "updatedAt": "2021-02-16T19:34:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "h3-datagram makes no mention of echoing at all. It does mention intermediary stripping though, My first impression is that echoing seems a function of CONNECT-UDP's usage of flow-id. Maybe I'm confused in the overlap?",
          "createdAt": "2021-02-16T20:12:37Z",
          "updatedAt": "2021-02-16T20:12:37Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, you're right! Maybe we should move echoing from connect-udp to h3-datagram? Do you have thoughts on that?",
          "createdAt": "2021-02-16T20:29:48Z",
          "updatedAt": "2021-02-16T20:29:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I probably need to think on it a bit. This seems like one of those difficult to avoid overlaps, so not surprised to see it.\r\n\r\nOn the one hand, I like that the concept of flow-id is somewhat abstract in h3-datagram. We don't need to get bogged down with some implementation detail that might not apply to a different kind of usage. \r\n\r\nOn the other hand, we do spend a whole section defining a header field encoding. So we could refer to the offer/echo pattern as one example way to do things. This might also lend itself nicely to discussing the echo behaviour when named parameters (or whatever we want to call them) are not understood, close to the definition of said parameters. \r\n\r\nI am probably slightly leaning to the second hand here but don't have many cycles to contribute a PR right now.",
          "createdAt": "2021-02-16T20:48:23Z",
          "updatedAt": "2021-02-16T20:48:23Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events: Datagram-Flow-Id was removed in 649890881aaa92548b5a0fb37a7622b409b281fd. Closing.",
          "createdAt": "2021-07-12T22:09:20Z",
          "updatedAt": "2021-07-12T22:09:20Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU4MjMyMzE2NTY=",
      "title": "Describe effects of connection migration with a proxy",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/42",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Jana and I were discussing some interesting effects of doing QUIC connection migration to a CONNECT-UDP proxy when the target server is running QUIC. I think the document should have a section to discuss considerations for migration.\r\n\r\nIn general, doing QUIC migration to a proxy is great, since it allows connections to migrate even when the target server may not support migration (which is particularly useful for TCP origins where you proxy via CONNECT). However, this also has the effect of hiding a migration event from a QUIC origin.\r\n\r\nA QUIC server responding to migration should reset its congestion window state, and ensure that it is conservative in sending until the new path is validated. The proxy can certainly do this, but a QUIC target origin won't know that this event has occurred, and may be sending quite a lot of data which will now be either queued at the proxy or dropped. We should have recommended behavior for the proxy to effectively get the target to slow down and recognize the congestion reset event. This may \"just work\" depending on how the proxy is implemented, but there could also be pitfalls.",
      "createdAt": "2021-03-05T16:19:33Z",
      "updatedAt": "2021-10-06T21:33:56Z",
      "closedAt": "2021-10-06T21:33:56Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good point, we should mention this in the draft. One solution could be to have the proxy switch target-facing UDP port and perform migration to the target server any time it sees a migration from the client.",
          "createdAt": "2021-03-05T16:32:47Z",
          "updatedAt": "2021-03-05T16:32:47Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, you can switch the port, but as Jana pointed out, that will look more like NAT rebinding, which may not cause all servers to fully reset their congestion.",
          "createdAt": "2021-03-05T16:53:34Z",
          "updatedAt": "2021-03-05T16:53:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's true, though I'm not sure there's much else the proxy can do? As long as the proxy behaves correctly on the client-facing connection (by resetting the congestion controller there therefore dropping incoming UDP packets that don't fit in the congestion window), this will just cause a burst of packet loss and the target server should react to that in one or two round trips.",
          "createdAt": "2021-03-05T17:37:45Z",
          "updatedAt": "2021-03-05T17:37:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I agree that that's likely the correct outcome here. I think the text mainly should describe that, mention you can change the port if you want to provide a bit of a signal, and also warn against queuing the packets at the proxy excessively. That last part should be done anyhow, but this case is one where even if the proxy has room in its buffers, it should be pretty aggressive about dropping to make the loss event obvious.",
          "createdAt": "2021-03-05T17:59:45Z",
          "updatedAt": "2021-03-05T17:59:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I agree with documenting this case for the proxy, although I might have opinions on any specific guidance. \r\n\r\nI wonder, more generally, if it would help to have an independent QUIC extension frame that endpoints can use to signal the other one that \"something happened\" . This would allow the client, fully aware of what it just did, to tell the remote target that something happened which might invalidate present state or asumptions about congestion-control state, PMTUD etc.",
          "createdAt": "2021-03-05T19:32:13Z",
          "updatedAt": "2021-03-05T19:32:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@tfpauly I just noticed #14. Should we mark this issue as a duplicate of that one and move the discussion there?",
          "createdAt": "2021-03-05T22:37:30Z",
          "updatedAt": "2021-03-05T22:37:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as duplicate of #14.",
          "createdAt": "2021-10-06T21:33:56Z",
          "updatedAt": "2021-10-06T21:33:56Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4Mjg0MTk1ODQ=",
      "title": "Move \"Stream Encoding of Proxied UDP Packets\" to a more appropriate location",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/43",
      "state": "CLOSED",
      "author": "achernya",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, the text of the connect-udp draft contains section \"Stream Encoding of Proxied UDP Packets\", which describes how H3_DATAGRAM can be sent over a reliable stream, e.g., for use with H2 or whenever reliable transmission of datagrams is needed.\r\n\r\nOne of the current ip-proxying-requirements is that we should be able to optionally transmit datagrams in a reliable fashion.\r\n\r\nWhen we get to writing an implementation of ip-proxying, it would be a bit off to cite the connect-udp draft. One way we could fix this is to move this section to the h3-datagram draft.",
      "createdAt": "2021-03-10T22:32:11Z",
      "updatedAt": "2021-07-12T22:10:09Z",
      "closedAt": "2021-07-12T22:10:09Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "NONE",
          "body": "I don't want to capture this issue, but I think we should actually reconsider if we really want different CONNECT-UDP and CONNECT_IP methods or just have one CONNECT-X method and provide information on which protocol headers are in the payload or not (and potentially need to be added by the proxy before sending the packet out) in e.g. a HTTP pseudo-headers.",
          "createdAt": "2021-04-15T18:15:33Z",
          "updatedAt": "2021-04-15T18:15:33Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events: that section was removed in 649890881aaa92548b5a0fb37a7622b409b281fd. Closing.",
          "createdAt": "2021-07-12T22:10:09Z",
          "updatedAt": "2021-07-12T22:10:09Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU4NjkxNjE2OTU=",
      "title": "What does it mean for a tunnel to not yet be formed?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/45",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "draft 03 states \r\n\r\n> Any 2xx (Successful) response\r\n   indicates that the proxy has opened a socket to the request-target\r\n   and is willing to proxy UDP payloads.  Any response other than a\r\n   successful response indicates that the tunnel has not yet been\r\n   formed.\r\n   \r\nthe use of \"not yet\" seems a little hand waving. What's the intent of the statement, I think it would help to be more specific. \r\n\r\nWe could presume that a non-final 1xx response could indicate that the tunnel is possibly yet to be created. \r\nWhereas a 4xx could mean that the client erred and that no tunnel is ever going to be created.\r\n\r\n",
      "createdAt": "2021-04-27T18:47:38Z",
      "updatedAt": "2021-10-07T00:10:22Z",
      "closedAt": "2021-10-07T00:10:22Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This text was lifted from the [definition of CONNECT](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.6) but I'm sure we can be even more clear. Can you propose some text?",
          "createdAt": "2021-04-27T19:00:25Z",
          "updatedAt": "2021-04-27T19:00:25Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "touch\u00e9\r\n\r\nSemantics still says it, so it must mean something https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.9.3.6\r\n\r\nBut both the H2 and H3 definitions don't really do any handwaving and just say https://tools.ietf.org/html/draft-ietf-quic-http-34#section-4.2\r\n\r\n>  A proxy that supports CONNECT establishes a TCP connection\r\n  [RFC0793] to the server identified in the \":authority\" pseudo-\r\n   header field.  Once this connection is successfully established, the\r\n   proxy sends a HEADERS frame containing a 2xx series status code to\r\n   the client, as defined in Section 15.3 of [SEMANTICS].\r\n\r\nSince CONNECT-UDP is trying to cover all 3 known major versions, it has to be careful. If I **had** to write a PR, I might try to combine the most up to date Semantics text with H2/H3, and in the process drop this \"not yet been fully formed\" clause. However, maybe I'm missing something that HTTP WG aficionados will tell be is really important.",
          "createdAt": "2021-04-27T19:13:10Z",
          "updatedAt": "2021-04-27T19:13:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "So I think it's pretty clear that 2xx means \"yes send me your UDP\" and 4xx/5xx means \"nope don't send your UDP\". I think the points that might need clarification are:\r\n1. are 1xx responses allowed?\r\n1. if 1xx is allowed, how does the client react?\r\n1. are 3xx allowed? \r\n1. if 3xx is allowed, how does the client react?",
          "createdAt": "2021-04-27T19:30:34Z",
          "updatedAt": "2021-04-27T19:30:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed by #54, closing.",
          "createdAt": "2021-10-07T00:10:22Z",
          "updatedAt": "2021-10-07T00:10:22Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU4NjkxNjkxNzk=",
      "title": "Stream lifecycle management",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/46",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is partly related to https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/17 but  seems to fit its own issue.\r\n\r\nLet's assume a CONNECT-UDP request succeeds with a 2xx and a flow of datagrams is merrily exchanged. How do endpoints indicate they are done with the stream and associated flows? The spec doesn't really say anything. \r\n\r\nThe main example I can think of is where a server decides to perform housekeeping on UDP connections (maybe as part of runtime garbage collection, or in reaction to the network stack throwing errors) after a 2xx was been sent. \r\n\r\nH3 CONNECT says\r\n\r\n>   The TCP connection can be closed by either peer.  When the client\r\n   ends the request stream (that is, the receive stream at the proxy\r\n   enters the \"Data Recvd\" state), the proxy will set the FIN bit on its\r\n   connection to the TCP server.  When the proxy receives a packet with\r\n   the FIN bit set, it will close the send stream that it sends to the\r\n   client.  TCP connections that remain half-closed in a single\r\n   direction are not invalid, but are often handled poorly by servers,\r\n   so clients SHOULD NOT close a stream for sending while they still\r\n   expect to receive data from the target of the CONNECT.\r\n\r\n >  A TCP connection error is signaled by abruptly terminating the\r\n   stream.  A proxy treats any error in the TCP connection, which\r\n   includes receiving a TCP segment with the RST bit set, as a stream\r\n   error of type H3_CONNECT_ERROR; see Section 8.  Correspondingly, if a\r\n   proxy detects an error with the stream or the QUIC connection, it\r\n   MUST close the TCP connection.  If the underlying TCP implementation\r\n   permits it, the proxy SHOULD send a TCP segment with the RST bit set.\r\n\r\nNot all of that guidance directly translates but I think it would be helpful to set some expectations for endpoints wrt how stream read or write states might change during the lifetime of a CONNECT-UDP request - especially in the cases where no stream data is being exchanged.",
      "createdAt": "2021-04-27T18:58:30Z",
      "updatedAt": "2021-09-10T20:26:40Z",
      "closedAt": "2021-09-10T20:26:40Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "I took \"FIN or RESET = done\" as a given, but it's worth stating.  Proxy behavior will likely be identical in both the graceful and abrupt closure cases.",
          "createdAt": "2021-07-23T18:50:37Z",
          "updatedAt": "2021-07-23T18:50:37Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU4OTQxOTA2NDg=",
      "title": "TURN and webtransport",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/47",
      "state": "CLOSED",
      "author": "unicomp21",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Thinking from a firewall perspective, and what ports are open now along with which ports will be open in the future, does running TURN over webtransport\u00a0make sense?\u00a0 I'm not entirely clear on Masque, what's the difference between TURN and Masque?",
      "createdAt": "2021-05-18T09:44:45Z",
      "updatedAt": "2021-05-25T16:06:23Z",
      "closedAt": "2021-05-24T15:46:13Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "MASQUE is about proxying arbitrary traffic over HTTP, see [the charter](https://datatracker.ietf.org/wg/masque/about/). If you're looking for WebTransport, you're in the wrong place. What are you trying to do?",
          "createdAt": "2021-05-18T17:03:13Z",
          "updatedAt": "2021-05-18T17:03:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as off-topic.",
          "createdAt": "2021-05-24T15:46:13Z",
          "updatedAt": "2021-05-24T15:46:13Z"
        },
        {
          "author": "unicomp21",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi  I'm trying to get browser based support for tunneling webrtc TURN traffic over http.  Kinda sounds like MASQUE, right?",
          "createdAt": "2021-05-25T10:48:34Z",
          "updatedAt": "2021-05-25T10:50:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@unicomp21 it does sound like MASQUE, but it's not specific to this git repository. Please join the MASQUE mailing list <https://www.ietf.org/mailman/listinfo/masque> then email <masque@ietf.org> with details of exactly what you're trying to do and why.",
          "createdAt": "2021-05-25T16:06:23Z",
          "updatedAt": "2021-05-25T16:06:23Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU5NDQ0NjQxOTI=",
      "title": "Registration capsule from proxy needed?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/48",
      "state": "CLOSED",
      "author": "ihlar",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section 4 states that the proxy responds to a CONNECT-UDP request with 2xx and a corresponding registration capsule to indicate end-to-end support of datagrams. \r\nIf the client sends a REGISTER_DATAGRAM_CONTEXT capsule, the corresponding capsule from the proxy will be of the same kind, and it will register a new server-generated context ID. So now we would have two context IDs for the same stream, which seems a bit unnecessary. \r\n\r\nCould we simply omit the step where the proxy sends a registration capsule and simply state that a 2xx response to the CONNECT-UDP request is sufficient indication of end-to-end datagram support?\r\n",
      "createdAt": "2021-07-14T14:04:34Z",
      "updatedAt": "2021-07-15T01:23:00Z",
      "closedAt": "2021-07-15T01:23:00Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "> If the client sends a REGISTER_DATAGRAM_CONTEXT capsule, the corresponding capsule from the proxy will be of the same kind, and it will register a new server-generated context ID.\r\n\r\nMy reading of the spec is different, https://datatracker.ietf.org/doc/html/draft-ietf-masque-h3-datagram-03#section-4.1 says\r\n\r\n> once a  context ID is registered, it can be used in both directions.\r\n\r\nSo for example, if the client sends a request on stream 4 and then REGISTER_DATAGRAM_CONTEXT { Context ID (0)}, the server will respond with REGISTER_DATAGRAM_CONTEXT { Context ID (0)} to confirm that the context is accepted. ",
          "createdAt": "2021-07-14T15:12:59Z",
          "updatedAt": "2021-07-14T15:12:59Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "NONE",
          "body": "> My reading of the spec is different, https://datatracker.ietf.org/doc/html/draft-ietf-masque-h3-datagram-03#section-4.1 says\r\n> \r\n> > once a  context ID is registered, it can be used in both directions.\r\n> \r\n> So for example, if the client sends a request on stream 4 and then REGISTER_DATAGRAM_CONTEXT { Context ID (0)}, the server will respond with REGISTER_DATAGRAM_CONTEXT { Context ID (0)} to confirm that the context is accepted.\r\n\r\nThat makes sense, I was assuming that the \"used in both directions\" referred to datagrams. I think my confusion in part came from the same section that says:\r\n\r\n> servers MUST NOT register client-initiated Context IDs.\r\n\r\nBut sending a registration capsule with an already registered context ID is not a new registration I suppose.\r\nMaybe it's good to clarify this a bit in the datagram spec. I'll open a separate issue there. \r\n",
          "createdAt": "2021-07-14T15:42:13Z",
          "updatedAt": "2021-07-14T15:42:13Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "> Maybe it's good to clarify this a bit in the datagram spec. I'll open a separate issue there.\r\n\r\nI agree the draft is a bit ambiguous here. ",
          "createdAt": "2021-07-14T15:45:22Z",
          "updatedAt": "2021-07-14T15:45:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed, the spec is unclear here, my apologies. I got this wrong when I rewrote the old Datagram-Flow-Id text. The server doesn't need to echo the registration capsule here since the client's registration is bidirectional.\r\n\r\n@LPardue we should add text to HTTP Datagrams to clarify what we want to do about echoing registrations, is it\r\n1. required\r\n2. allowed\r\n3. forbidden\r\n\r\nI'm leaning towards (3) unless we have a use case for communicating the fact that a context is \"accepted\" and in which case I'd say (2).",
          "createdAt": "2021-07-14T16:05:22Z",
          "updatedAt": "2021-07-14T16:05:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Aha! In that case I apologise too. This seems important for interop!\r\n\r\nNow I remember, I think some people felt registration ack wasn't needed as long as there was a way to reject. And we have that with CLOSE_DATAGRAM_CONTEXT. So I think (3), modelled as implicit accept and explicit close, sounds good. That cuts down the chatter (and probably simplifies some code in my implementation).",
          "createdAt": "2021-07-14T16:16:28Z",
          "updatedAt": "2021-07-14T16:16:28Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU5NTE4NjUxMzQ=",
      "title": "Datagram Context Identification",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/50",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The CONNECT-UDP spec currently says:\r\n\r\n> In order to use HTTP Datagrams, the CONNECT-UDP client will first decide whether or not to use HTTP Datagram Contexts and then register its context ID (or lack thereof) using the corresponding registration capsule, see [HTTP-DGRAM].\r\n\r\nHowever, in the event that the client registers multiple context IDs, the spec provides no guidance on identifying which context is the stream of datagrams to be sent versus some other series of datagrams that might be tied to some other protocol feature.  That implicitly assumes that there will never be a use of H3 datagrams other than CONNECT-UDP and its extensions.\r\n\r\nI think there needs to be an identifier registered for CONNECT-UDP payloads to handle this case.  If _NOCONTEXT is used, it's pretty clear that the \"default context\" had better be the payload of the CONNECT-UDP method (unless you plan to use capsules only, I suppose), but it's probably worth stating explicitly.  There should also be some language about what happens if multiple contexts of that type are present -- presumably they're all equally valid, and could potentially be using different CONNECT-UDP extensions, such as different ECN values.",
      "createdAt": "2021-07-23T20:07:38Z",
      "updatedAt": "2021-10-06T21:47:47Z",
      "closedAt": "2021-10-06T21:47:47Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'd be happy with CONNECT-UDP + Register with No Context Extension meaning default processing and forwarding. Registering multiple default contexts is probably pointless but there might be something to say there if, hypothetically, you could prioritize datagram contexts and people want to be able to prioritize different datagram flows to the same CONNECT-UDP target.\r\n\r\nIf any other behaviour is required, then Context Extensions are needed.",
          "createdAt": "2021-07-23T20:35:51Z",
          "updatedAt": "2021-07-23T20:35:51Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "In a discussion with @tfpauly, he suggested that the \"type\" might always be scoped by the method.  Extrapolating from that, _all_ contexts under CONNECT-UDP would contain datagrams to be forwarded and extensions express different variations on that idea (priority, timestamps, etc.).\r\n\r\nThat assumes, of course, that we don't mint an extension that isn't a packet of some form (confirmation packet was sent on, RTT samples from proxy-to-origin side, etc.), or at least there are no types of datagrams associated with an HTTP stream which aren't defined and supported specifically for that method.",
          "createdAt": "2021-07-23T21:04:49Z",
          "updatedAt": "2021-07-23T21:04:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by cdce7eb2e49fb32ce1cb57e88a453bce96106fa8.",
          "createdAt": "2021-10-06T21:47:47Z",
          "updatedAt": "2021-10-06T21:47:47Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU5ODE3MjE2MDM=",
      "title": "We don't need DATAGRAM",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/51",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Sec. 4 it says:\r\n\r\nIf negotiation of HTTP Datagrams fails (for example if an HTTP/3 SETTINGS frame was received without the H3_DATAGRAM SETTINGS Parameter), the client MUST consider its CONNECT-UDP request as failed.\r\n\r\nIIUC it is entirely possible to do CONNECT-UDP entirely with CAPSULE frames, so I don't see why a client should fail the attempt because the first hop is H/2 only, or whatever.",
      "createdAt": "2021-08-28T04:10:31Z",
      "updatedAt": "2021-09-10T02:00:06Z",
      "closedAt": "2021-09-10T02:00:06Z",
      "comments": []
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU5OTUwOTQ2ODE=",
      "title": "Masque TCP with Extended CONNECT:  connect-tcp / masque-tcp",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/55",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "With the switch to use Extended CONNECT in #54 for UDP, it seems logical to shift TCP to also use the same model.   Two approaches would either be for a new draft (draft-ietf-masque-connect-tcp?), or to generalize the connect-udp draft since there is lots in-common given how things are now factored.",
      "createdAt": "2021-09-13T16:32:13Z",
      "updatedAt": "2021-11-05T01:05:47Z",
      "closedAt": "2021-11-05T01:05:47Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking about that when I wrote the PR and I agree",
          "createdAt": "2021-09-13T16:42:09Z",
          "updatedAt": "2021-09-13T16:42:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'd worry accommodating TCP is scope creep for this draft.\r\n\r\nH2 and H3 CONNECT already support TCP. Extended CONNECT might be nicer but then we'd probably want text to explain why endpoints might choose one or another.  That seems better suited to some other document to me right now. \r\n\r\nedit: I also think the HTTP WG could probably own that work\r\n",
          "createdAt": "2021-09-13T16:50:06Z",
          "updatedAt": "2021-09-13T16:50:49Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm realizing my \"I agree\" wasn't very specific, I meant: I agree that we should do the same for TCP. I didn't have a strong opinion for this draft vs a new draft, but based on https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/55#issuecomment-918381420 I think a separate draft might be best",
          "createdAt": "2021-09-13T16:52:01Z",
          "updatedAt": "2021-09-13T16:52:01Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, this should probably be a separate draft, but defining connect-tcp would be nice to make things more parallel.",
          "createdAt": "2021-10-04T20:35:54Z",
          "updatedAt": "2021-10-04T20:35:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue since we'll want to do this in a separate draft",
          "createdAt": "2021-11-05T01:05:47Z",
          "updatedAt": "2021-11-05T01:05:47Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "MDU6SXNzdWU5OTUwOTg1OTc=",
      "title": "Extended CONNECT bikesheds",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/56",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Some potential bikesheds/comments from #54 (which generally looks good):\r\n\r\n1) For HTTP/1.1, should the method be \"GET\" or \"CONNECT\"?  WebSockets uses GET -- are there any uses of \"Extended CONNECT\" that use CONNECT rather than GET?\r\n2) Should the default URI template have a /.well-known prefix?  For example, \"/.well-known/masque/udp/{target_host}/{target_port}/\" ?\r\n3) Should the upgrade token be \"connect-udp\" or \"masque-udp\" ? \r\n",
      "createdAt": "2021-09-13T16:36:40Z",
      "updatedAt": "2021-09-13T16:46:01Z",
      "closedAt": "2021-09-13T16:46:00Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Great questions, but let's keep one issue per topic, I've opened #57, #58, and #59 to track these individual points.",
          "createdAt": "2021-09-13T16:46:00Z",
          "updatedAt": "2021-09-13T16:46:00Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU5OTUxMDYwNDk=",
      "title": "HTTP/1.1 Method for Upgrade",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/57",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For HTTP/1.1, should the method be \"GET\" or \"CONNECT\"? WebSockets uses GET -- are there any uses of \"Extended CONNECT\" that use CONNECT rather than GET?\r\n\r\n(issue based on #56 by @enygren)",
      "createdAt": "2021-09-13T16:45:05Z",
      "updatedAt": "2021-09-13T16:45:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU5OTUxMDYwODA=",
      "title": "Well-known prefix for default URI template",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/58",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should the default URI template have a /.well-known prefix? For example, `/.well-known/masque/udp/{target_host}/{target_port}/` ?\r\n\r\n(issue based on #56 by @enygren)",
      "createdAt": "2021-09-13T16:45:08Z",
      "updatedAt": "2021-09-13T16:45:08Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU5OTUxMDYxMjg=",
      "title": "Upgrade token bikeshed",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/59",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should the upgrade token be \"connect-udp\" or \"masque-udp\" ?\r\n\r\n(issue based on #56 by @enygren)",
      "createdAt": "2021-09-13T16:45:11Z",
      "updatedAt": "2021-10-06T21:50:20Z",
      "closedAt": "2021-10-06T21:50:20Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I vote for `connect-udp` or something along those lines. \"MASQUE\" is good as a working group name, but I don't think it's helpful in the protocol to help people understand what the variant of CONNECT does.",
          "createdAt": "2021-09-20T14:44:24Z",
          "updatedAt": "2021-09-20T14:44:24Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "I_kwDOETZKbc49LfNn",
      "title": "Practical limits to the size of DATAGRAM capsules",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/64",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When the client <-> proxy hop is HTTP/3, and HTTP/3 datagrams are in use, the practical limit of datagrams is the maximum size of a QUIC packet minus header overheads. \r\n\r\nWhen DATAGRAM capsules are used, the logical limit is increased to that of an entire data stream. For the UDP proxying use case, a proxy that converts capsules into UDP datagrams will have a practical limit to the size of UDP datagrams that it can send. And it most likely wants to avoid fragmentation. When fragmentation is to be avoided, I would expect many proxy implementations to have a practical limit of less than 2000 for the size they would be willing to send. Such proxies can drop the contents of too-large datagrams but they would be required to drain them completely in order to continue reading the data stream. This seems like a possible avenue for DoS, because a client could send a $very_large datagram capsule that can never be sent by a proxy. Alternatively, if a proxy _could_ send a $very_large datagram in theory, it would need to buffer the entirety of the datagram before sending it. \r\n\r\nWe might be tempted to try to create some way for endpoints to communicate the practical limit of datagram capsules. But that could be hard due to the end-to-end version-indendent design. Instead we might just provide some guidance that $very_large capsules might cause problems for implementations, and that receivers might have local (or implementation-specific) limits that they want to enforce, which they could do by closing the stream or closing the connection.\r\n",
      "createdAt": "2021-10-14T13:46:20Z",
      "updatedAt": "2021-10-14T18:10:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "According to RFC 768, the maximum length of a UDP payload is 65527. I would add some text to draft-ietf-masque-connect-udp along the lines of:\r\n> Endpoints MUST NOT send datagrams with payloads longer than 65527 using the Datagram Format Type UDP_PAYLOAD. An endpoint that receives a DATAGRAM capsule using Datagram Format Type UDP_PAYLOAD whose payload is longer than 65527 MUST abort the stream. If a proxy known it can only send out UDP packets of a certain length due to its underlying link MTU, it SHOULD discard incoming DATAGRAM capsules using Datagram Format Type UDP_PAYLOAD whose payload is longer than that limit without buffering the capsule contents.\r\n\r\nAdditionally, I think we could add some guidance text to draft-ietf-masque-h3-datagram along the lines of:\r\n> While DATAGRAM capsules can theoretically carry a payload of length 2^62-1, most applications will have their own limits on what datagran payload sizes are practical. Implementations SHOULD take those limits into account when parsing DATAGRAM capsules: if in incoming DATAGRAM capsule has a length that is known to be so high as to not be usable, the implementation SHOULD discard the capsule without buffering its contents into memory.\r\n\r\nI would leave the communication of actual limits to an extension.",
          "createdAt": "2021-10-14T17:27:46Z",
          "updatedAt": "2021-10-14T17:27:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Yeah we don't need to be 100% prescriptive, just spelling out foothold WFM",
          "createdAt": "2021-10-14T18:10:04Z",
          "updatedAt": "2021-10-14T18:10:04Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOETZKbc4-Tvvt",
      "title": "URI template or HTTP headers?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/65",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[draft-ietf-masque-connect-udp-06 currently uses a URI template to configure clients](https://datatracker.ietf.org/doc/html/draft-ietf-masque-connect-udp-06#section-2). That template contains the `target_host` and `target_port` variables which convey the target host/port in the `:path` pseudo-header. This has the following benefits:\r\n- allows custom schemes\r\n- allows proxy to pick path they use\r\n\r\nHowever it has downsides:\r\n- it requires parsing URI templates which is more of a pain than it seems\r\n- it prevents reusing the same configuration between CONNECT-UDP and CONNECT-IP\r\n\r\nAlternatively, we could replace the configuration URI template with a configuration URL, and instead convey the target host/port in separate HTTP headers. This has the same benefits of the URI template without the downsides.",
      "createdAt": "2021-11-05T01:11:38Z",
      "updatedAt": "2021-11-05T01:11:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 66,
      "id": "I_kwDOETZKbc4-ZbbK",
      "title": "SHOULD use HTTP/3 Datagrams",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/66",
      "state": "OPEN",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": ">    When the protocol running over UDP that is being proxied uses loss\r\n   recovery (e.g., [QUIC]), and the underlying HTTP connection runs over\r\n   TCP, the proxied traffic will incur at least two nested loss recovery\r\n   mechanisms.  This can reduce performance as both can sometimes\r\n   independently retransmit the same data.  To avoid this, HTTP/3\r\n   datagrams SHOULD be used.\r\n\r\nThis text could maybe be clearer. Is it trying to say \"You SHOULD use H3 + Datagram\" or \"You SHOULD use H3 and if you do you should use datagram\". I.e., is it possible to use H3 but not datagram?\r\n",
      "createdAt": "2021-11-07T21:24:15Z",
      "updatedAt": "2021-11-08T02:49:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "You're right, this is unclear. That text predates the refactor of HTTP/3 Datagram to HTTP Datagrams, so we should tweak it to say \"To avoid this, UDP proxying SHOULD be performed over HTTP/3 to allow leveraging the QUIC DATAGRAM frame.\"",
          "createdAt": "2021-11-08T02:49:39Z",
          "updatedAt": "2021-11-08T02:49:39Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOETZKbc4-ZbgW",
      "title": "MUST NOT Introspect",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/67",
      "state": "OPEN",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": ">    Because the CONNECT method creates a TCP connection to the target,\r\n   the target has to indicate its willingness to accept TCP connections\r\n   by responding with a TCP SYN-ACK before the proxy can send it\r\n   application data.  UDP doesn't have this property, so a UDP proxy\r\n   could send more data to an unwilling target than a CONNECT proxy.\r\n   However, in practice denial of service attacks target open TCP ports\r\n   so the TCP SYN-ACK does not offer much protection in real scenarios.\r\n   Proxies MUST NOT introspect the contents of UDP payloads as that\r\n   would lead to ossification of UDP-based protocols by proxies.\r\n\r\nThis seems like an RFC 6919 \"MUST (but we know you won't)\"",
      "createdAt": "2021-11-07T21:25:52Z",
      "updatedAt": "2021-11-08T04:01:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Are you proposing a change to the draft?",
          "createdAt": "2021-11-08T02:50:30Z",
          "updatedAt": "2021-11-08T02:50:30Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "Yes. I would remove the last sentence. OTOH, given that the status of proxies is still under discussion maybe we just wait on this one.",
          "createdAt": "2021-11-08T04:01:02Z",
          "updatedAt": "2021-11-08T04:01:02Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOETZKbc4_kaDu",
      "title": "Add to security considerations that it's not possible to generate CONNECT from JS",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/68",
      "state": "OPEN",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "And point to https://fetch.spec.whatwg.org/#methods\r\n\r\nThis is an important part of the security analysis.",
      "createdAt": "2021-11-29T21:11:59Z",
      "updatedAt": "2021-11-30T00:15:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Only if you believe that the Sec- prefix is useful for the Capsule-Protocol header field.  I don't.",
          "createdAt": "2021-11-29T21:18:51Z",
          "updatedAt": "2021-11-29T21:18:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "Sorry, I don't mean that it's the only thing that makes it work, merely that if were going to talk about how to analyze it, this is something we should say.",
          "createdAt": "2021-11-29T21:30:43Z",
          "updatedAt": "2021-11-29T21:30:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr can you clarify your intent? Your issue title starts with \"Add to JS\" but I suspect you didn't mean that we should modify the JavaScript specification. Would a note next to where the \"Capsule-Protocol\" header is defined resolve this?",
          "createdAt": "2021-11-29T23:51:29Z",
          "updatedAt": "2021-11-29T23:51:29Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "Aaargh. I meant \"add to the security considerations\". ",
          "createdAt": "2021-11-29T23:54:41Z",
          "updatedAt": "2021-11-29T23:54:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, that makes more sense :) Adding something to security considerations sounds good to me, I'll add text to the [PR](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124).\r\n\r\nNote that this was filed on the wrong repository, [draft-ietf-masque-h3-datagram](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues) is the droid you're looking for.",
          "createdAt": "2021-11-30T00:15:07Z",
          "updatedAt": "2021-11-30T00:15:07Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOETZKbc4_kfCW",
      "title": "Conditions on datagram forwarding",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/69",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> An intermediary that understands the request semantics enough to know that capsules are in use MAY convert between QUIC DATAGRAM frames and DATAGRAM capsules\r\n\r\nI think that this is right, but we should be more precise about what this means.\r\n\r\nThat is, if the method is CONNECT and either:\r\n\r\n1. the intermediary understands the :protocol selection, or\r\n2. the request includes Capsule-Protocol\r\n\r\nThen the intermediary can forward DATAGRAM capsules as QUIC DATAGRAM frames or forward QUIC DATAGRAM frames as DATAGRAM capsules.\r\n\r\nThose conditions could be spelled out more clearly.",
      "createdAt": "2021-11-29T21:36:57Z",
      "updatedAt": "2021-11-29T23:56:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree. I'll add this to the [PR](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124).\r\n\r\nNote that this was filed on the wrong repository, [draft-ietf-masque-h3-datagram](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues) is the droid you're looking for.",
          "createdAt": "2021-11-29T23:56:01Z",
          "updatedAt": "2021-11-29T23:56:01Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDOETZKbc4_ojF2",
      "title": "What is the justification for dynamic context registration in CONNECT UDP?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/71",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Based on the current direction of the design team, I don't understand the justification for using dynamic context registration as the primary extension mechanism for CONNECT-UDP.  It seems like a more static format would be simpler and more performant, and cover the use-cases I'm aware of.  Specifically, use the bits of the varint at the beginning of a CONNECT-UDP datagram to determine the ECN state and/or presence of timestamps.\r\n\r\nWith this scheme, clients do not need to send any capsules, and servers do not need to buffer datagrams with an ID referencing an unregistered context.\r\n\r\nIf there is an extension that is more complicated and requires dynamic contexts, it can use a bit in the varint to indicate the presence of a context-ID.",
      "createdAt": "2021-11-30T19:24:53Z",
      "updatedAt": "2021-12-10T00:06:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "There is no way to signal whether endpoints actually support any \"preregistered contexts\", so (1) they must be decided Once And For All at specification time and (2) they all must be Mandatory To Implement.  That adds complexity to the minimal compliant implementation.\r\n\r\nIn contrast, dynamic registration adds no complexity burden to a simple implementation that doesn't support extensions.  It just has to (somehow...) say \"NO\" to any context registration attempt.",
          "createdAt": "2021-11-30T19:39:47Z",
          "updatedAt": "2021-11-30T19:39:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> It seems like a more static format would be simpler and more performant\r\n\r\nCan you elaborate on this? Sending a 3-byte capsule right after the headers is negligible overhead.\r\n\r\n> Specifically, use the bits of the varint at the beginning of a CONNECT-UDP datagram to determine the ECN state and/or presence of timestamps.\r\n\r\nThis can be accomplished via dynamic allocations: just register 4 context IDs, one for each ECN value.\r\n\r\n> If there is an extension that is more complicated and requires dynamic contexts, it can use a bit in the varint to indicate the presence of a context-ID.\r\n\r\nHow does this work? With the static model, we'd have an IANA registry for context IDs - how does one \"use a bit\" there?\r\n\r\n",
          "createdAt": "2021-11-30T19:41:44Z",
          "updatedAt": "2021-11-30T19:41:44Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Let me make a concrete example proposal:\r\n\r\nFirst, forget you ever heard the word context :)\r\n\r\nThe varint at the beginning of a CONNECT UDP payload is as follows.\r\n\r\nTwo LSBs: ECN bits\r\nNext LSB: Timestamp Present\r\nAll other bits: To be defined by other extensions\r\n\r\nvarint = 0 still means no extensions, just payload.\r\n\r\nThe IANA registry covers the standard usage of the other bits of the varint.  Does IANA allow you to do this?  In the worst case, every new bit registered doubles the number of entries in the registry.\r\n\r\nThis covers the two most common extension examples given in a very simple way.  It is more performant in the case of reordering of datagrams and registration capsules at the endpoint -- the datagram is always self-describing and can be processed immediately.  It requires no state or lookups.  It's also fewer bytes on the wire, but I don't think that's a convincing argument.\r\n\r\nIt doesn't require all extensions to be known at specification time either.  New extensions use new bits, and endpoints that don't support those extensions will drop the datagrams.  SETTINGS or Capsules or HTTP headers can be used to negotiate capabilities if that's desired.",
          "createdAt": "2021-11-30T20:09:20Z",
          "updatedAt": "2021-11-30T20:09:20Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "It sounds like you're proposing a flag field instead of an integer. That limits us to 62 extensions instead of 2^62. I don't think flags are the way to go, since not all extensions will be composable.",
          "createdAt": "2021-11-30T20:19:07Z",
          "updatedAt": "2021-11-30T20:19:07Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> That limits us to 62 extensions instead of 2^62\r\n\r\nAs Victor mentioned, you can always define the last flag to mean \"more flags\".  And I doubt we'll ever get to 62 extensions to CONNECT-UDP.\r\n\r\n> not all extensions will be composable\r\n\r\nI'm sympathetic to this argument on ideological grounds -- I don't like it to be possible to express a nonsensical combination of options. Do you have examples of extensions that are not composable?  Is it worth adding the complexity for the simplest and most common extensions to support these cases?\r\n\r\nCan you list the advantages of dynamic context registration?",
          "createdAt": "2021-11-30T20:39:50Z",
          "updatedAt": "2021-11-30T20:39:50Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "There's a forecasting element here.  Here are some forecasts for extensions to CONNECT-UDP:\r\n\r\nMetadata:\r\n\r\n* ECN\r\n* TIMESTAMP\r\n* DSCP\r\n* TTL\r\n\r\nNew contents:\r\n\r\n* ICMP errors\r\n* Datagram PING\r\n\r\nCompressed representations:\r\n\r\n* QUIC\r\n* SRTP\r\n* etc.\r\n\r\nHeader compression is highly stateful and dynamic, so it'll need the full dynamic context system.  Bitfield and dynamic contexts can be combined, but once you have dynamic contexts it's not clear to me what value the bitfield approach is adding.\r\n\r\nRegarding incompatibility: PING cannot meaningfully be combined with ECN, nor with (say) a QUIC-specific header compression scheme.",
          "createdAt": "2021-11-30T20:51:13Z",
          "updatedAt": "2021-11-30T20:51:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> As Victor mentioned, you can always define the last flag to mean \"more flags\". And I doubt we'll ever get to 62 extensions to CONNECT-UDP.\r\n\r\nSmall codepoint spaces make experimenting with draft extensions incredibly difficult, as we've seen with other protocols.\r\n\r\n> Do you have examples of extensions that are not composable?\r\n\r\nYou can't compose ECN with the ping (PMTUD) extension.\r\n\r\n> Is it worth adding the complexity for the simplest and most common extensions to support these cases?\r\n\r\nWhat \"complexity\" is being added here? Capsules are not complex.\r\n\r\nAlso, we can't predict which extensions will be the most common.\r\n\r\n> Can you list the advantages of dynamic context registration?\r\n\r\n* It's more flexible: you can support all known types of extensions\r\n* Base spec complexity is very minimal (see how short #70 is)\r\n* Less procedural overhead: no added IANA registry\r\n* No accidental composability of non-composable extensions\r\n* Since this is very likely what we'll use for CONNECT-IP, this allows reusing code.\r\n* It allows us to build compression extensions, such as compressing QUIC connection IDs",
          "createdAt": "2021-11-30T20:54:40Z",
          "updatedAt": "2021-11-30T21:09:12Z"
        },
        {
          "author": "achernya",
          "authorAssociation": "NONE",
          "body": "I'm not a fan of the flag register approach, and much prefer the varint with its 2^62 capabilities. I think that any \"static allocation\" that is used can be represented as early messages (as @DavidSchinazi proposed above) or could be side-band information in the headers attached to the request. In other words, I feel like from a CONNECT-UDP perspective, the \"fully dynamic\" model is actually preferable.",
          "createdAt": "2021-11-30T23:22:14Z",
          "updatedAt": "2021-11-30T23:22:14Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Thanks for the list of possible extensions and advantages -- that's really what I was trying to get when I opened the issue :) \r\n\r\nLooking at Ben's list, here's a non-flag based design that costs 1 byte for extensions:\r\n\r\n1. The varint is one of [UDP Payload, UDP Payload with Metadata, PING, ICMP Error, Compressed UDP payload, future extension types...]\r\n2. The extension types include the additional data they need -- maybe Metadata has a flags byte and Compressed UDP payload has a compression context ID.\r\n\r\nI recognize the dynamic context registration mechanism solves this problem generically, and does so with minimal encoding on the wire.  The cost is that all extended datagrams must use the stateful context mechanism -- even those with no state (like PING) or state that's no larger than a context ID (ECN).  Even some extensions that have larger state might prefer to serialize it on the wire.  The QPACK dynamic table may be a good analogy: some clients choose to encode literal headers on the wire rather than mess with the state: even though it's demonstrably less wire-efficient, it's just simpler.",
          "createdAt": "2021-12-01T00:54:39Z",
          "updatedAt": "2021-12-01T00:54:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you explain what you mean by \"simpler\"? To me the dynamic context registration system feels a lot simpler than this latest proposal, both simpler to implement and simpler to write the spec.",
          "createdAt": "2021-12-01T02:22:13Z",
          "updatedAt": "2021-12-01T02:22:13Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I think your view of what is simple is colored by having been invested in the stateful context approach for a long time and already having an implementation of it.  Instead take the view of someone new to the spec, with no code yet, who wants to write an extension.\r\n\r\nApproach 1:\r\n\r\nDefine new datagram type\r\nSend datagrams with new type\r\nParse datagrams with new type\r\nProfit\r\nBonus: reordering is a no-op.\r\n\r\nApproach 2:\r\n\r\nDefine new capsule type\r\nSend capsule binding a context ID to the type\r\nSend datagrams with context ID\r\nParse datagrams with context ID\r\nProfit\r\nPenalty: Datagram and Capsule re-ordering can cause buffering or drops at the receiver.\r\nPenalty: The context has to be re-registered for every request\r\nSecurity Consideration: Limiting the size of the context state\r\n\r\nTo me, approach 1 is simpler to implement and simpler to specify.  It doesn't preclude stateful extensions, it just requires them to send one extra byte.",
          "createdAt": "2021-12-01T17:52:20Z",
          "updatedAt": "2021-12-01T17:52:20Z"
        },
        {
          "author": "achernya",
          "authorAssociation": "NONE",
          "body": "> Penalty: Datagram and Capsule re-ordering can cause buffering or drops at the receiver.\r\n\r\nThat only exists if you opportunistically send the datagrams before waiting for the capsule registration acknowledgement, and also the receiver does not buffer the datagram in early connection startup.\r\n\r\n> Penalty: The context has to be re-registered for every request\r\n\r\nThat also only exists if you do not define profiles with side-band information, which produces the Approach 1 flow you were desiring. This isn't a property of static vs dynamic, it's a property of a-priori knowledge. The only difference with approach 1 is you're requiring everyone to have a-priori knowledge. You can do that with a dynamic registration system too.",
          "createdAt": "2021-12-01T18:18:40Z",
          "updatedAt": "2021-12-01T18:18:40Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Penalty: Datagram and Capsule re-ordering can cause buffering or drops at the receiver.\r\n\r\nThat's not right. Both approaches need to handle the scenario where a DATAGRAM frame is reordered ahead of the STREAM frame that contains HEADERS. Any implementation of CONNECT-UDP needs to handle this scenario asynchronously, and registering on receiving headers vs registering on receiving capsule have the same complexity.\r\n\r\n> Penalty: The context has to be re-registered for every request\r\n\r\nSending ~3 bytes is not a penalty worth worrying about.\r\n\r\n> Security Consideration: Limiting the size of the context state\r\n\r\nThat's trivial for extensions that only need one type - you reset the stream if you receive a second capsule.\r\n\r\n> To me, approach 1 is simpler to implement\r\n\r\nMight I suggest implementing CONNECT-UDP? Your assumptions aren't quite right here.\r\n\r\n> and simpler to specify.\r\n\r\nI doubt it, if you'd like to write a PR for that approach I'm pretty sure it'll be longer than #70.\r\n\r\n> It doesn't preclude stateful extensions, it just requires them to send one extra byte.\r\n\r\nThat type approach adds a layer of indirection which doesn't provide a lot of value. Abstractions aren't free.\r\n\r\n",
          "createdAt": "2021-12-01T18:44:28Z",
          "updatedAt": "2021-12-01T18:44:28Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> That also only exists if you do not define profiles with side-band information\r\n\r\nI see, so perhaps I can define a SETTING that pre-allocates some context IDs to have certain meanings (does SETTINGS count as side-band)?\r\n\r\n> The only difference with approach 1 is you're requiring everyone to have a-priori knowledge. You can do that with a dynamic registration system too\r\n\r\nI didn't mean to imply that extensions wouldn't be negotiated in approach 1.  Perhaps the point is that if you use capsules for negotiation of extensions, and you do this per-request, then 1 and 2 look more similar.  There's still the issue of having to keep state and manage it when not all extensions require this.",
          "createdAt": "2021-12-01T18:45:33Z",
          "updatedAt": "2021-12-01T18:45:33Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> That's not right. Both approaches...\r\n\r\nAgreed.  The machinery to buffer on reordering is the same.\r\n\r\n> Sending ~3 bytes is not a penalty worth worrying about.\r\n\r\nI never worry about the bytes.  The penalty is that you have to do it to make it work.\r\n\r\n> That's trivial for extensions that only need one type - you reset the stream if you receive a second capsule.\r\n\r\nIt's even more trivial if it is impossible.  I put this under the same category as \"non-composable extensions\".  \r\n\r\n> Might I suggest implementing CONNECT-UDP? Your assumptions aren't quite right here.\r\n\r\nWe have an implementation of CONNECT-UDP: https://github.com/facebook/proxygen/blob/main/proxygen/lib/http/session/HQSession.cpp#L3740\r\n\r\nWe always use context-ID 0, both because the machinery for contexts has been in a high state of flux, and because we've been hoping that their use is sequestered only to extensions that really require them.\r\n\r\n> I doubt it, if you'd like to write a PR for that approach I'm pretty sure it'll be longer than #70\r\n\r\nHere it is based on #70.  It's the same length.  The text is a few lines shorter and there's an IANA table.\r\n\r\nhttps://github.com/afrind/draft-ietf-masque-connect-udp/pull/1\r\n\r\n> Abstractions aren't free.\r\n\r\n100%.  I think the context abstraction is the one with conceptual cost, hence I'm trying to isolate it only to use cases that cannot be accomplished any other way (compression).  \"Define a new code point for your extension\" seems to be a pretty common extension mechanism.\r\n\r\nMaybe @martinthomson agrees?\r\n\r\n",
          "createdAt": "2021-12-01T19:27:16Z",
          "updatedAt": "2021-12-01T19:27:16Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "In my view, this proposal is likely \"simpler\" for endpoints that just support a handful of static, Mandatory-To-Implement extensions.  However, it is more complicated for a minimal implementation (because it introduces MTI extensions) and more complicated for a maximal implementation (which must implement both the bitfield-style and the dynamic-registration patterns).\r\n\r\n> I see, so perhaps I can define a SETTING that pre-allocates some context IDs to have certain meanings\r\n\r\nSETTINGS is hop-by-hop, so it would be a Header.  This is a reasonable pattern for \"up-front allocation\", but anything that can be done this way could also be done via Capsule.  Given the need for Capsule-based registration for dynamic extensions, adding a second registration mechanism seems like additive complexity.  This is why I think static allocation would only make sense for MTI extensions.  However, I don't see any of the proposed extensions as sufficiently valuable to warrant MTI status.",
          "createdAt": "2021-12-01T20:15:53Z",
          "updatedAt": "2021-12-01T20:15:53Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "Can we just use uint64_t for the IDs like QUIC v1, so that they would never collide?\r\n\r\nI'm not following the discussion in the design group and I could well be missing something, but to me it seems that the necessity for negotiations stems from the desire to _always_ use a very compact representation for the IDs being used.\r\n\r\nBut we did not choose such a design in QUIC v1 which is our underlying protocol. In QUIC v1, we decided that we can allocate short frame IDs (below 64) for types that we think are going to be used frequently, while for less-frequently used frame IDs allocating numbers that require multi-byte encoding.",
          "createdAt": "2021-12-02T02:33:44Z",
          "updatedAt": "2021-12-02T02:33:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Varint encoding exists to support an asymmetric frequency distribution.  That might be the result of natural biases (core QUIC frames will be more common than most extension QUIC frames) or the result of the usage (low-numbered stream IDs are more common than high-numbered).  Whether varint is the right choice here depends largely on what is being identified.\r\n\r\nAnd I think that Alan is suggesting something that might be a little less extensible or generic than what is being proposed otherwise.  That's reasonable.  This is UDP, for which the space of possibilities is pretty narrow.  We have a fair idea that some people will want ECN, some might want a subset of ICMP features, some might want flow labels, and some might have unanticipated needs.  Carving out space for \"just UDP\", \"UDP with ECN\", and \"UDP with timestamps\" might not be a bad use of a few bits, rather than using a generic system.\r\n\r\nThe potential for unanticipated needs suggests that some form of extension capability is worthwhile, but I think where we are disagreeing is the extent to which that capability needs to be central to the design.\r\n\r\nIf we (again) look at QUIC, the extension model for framing is pre-arrangement.  We don't have zero-latency setup for extensibility, even though some extensions can carry their extension across using 0-RTT.  That's simple, and we have reserved capacity in the frame types that allows endpoints to use those extensions seamlessly once they confirm that support is present.  But there the mapping is static: a given identifier means the same in every context, the negotiation only turns it on and off.\r\n\r\nDynamic allocation sounds dandy, but I think you are going to want to need it before going there.  For an intermediary that might ultimately want to forward at line rates, non-static mapping is more costly.  And it more costly at a conceptual level: you require access to state in order to make sense of anything.\r\n\r\nA dynamic allocation policy is good if there is a need to tightly manage the number of bytes you are allocating.  Perhaps the number of identifiers is scarce (see RTP for an example) or maybe you are looking to make the most out of an MTU (connect-IP might benefit here).  Ben is right that if you don't need any of the extensibility, then it is easier to ignore it, but that depends on carving out some portion of the space for non-dynamic use (0 == datagram is very much static).  As soon as you decide that you need ECN, if ECN is dynamically negotiated, it's more complicated to implement than a purely static mapping.\r\n\r\nFor UDP forwarding, the number of use cases is limited.  I'd be relatively comfortable with Alan's idea.  I'd go further and ditch the varints.  Just have 8 flags, with two of those reserved for ECN.  We don't need a framework: other flags can be dynamically allocated; others might be statically allocated (the top two bits might be reserved for \"8 more bits, 24 more bits, and 56 more bits\" if you felt like it).  We don't necessarily have to decide now.  All that needs is that you require endpoints to discard datagrams with non-zero values in places they don't expect.\r\n\r\nThe story with IP does seem to be different as it seems like compression is more likely.",
          "createdAt": "2021-12-02T03:10:27Z",
          "updatedAt": "2021-12-02T03:10:27Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I think QUIC header compression is likely to be an early, popular extension for CONNECT-UDP.  This is a fully dynamic extension: each context carries metadata that is not known until after the packets are flowing.\r\n\r\nI predict that most CONNECT-UDP implementations will fall into one of two categories: \"minimal\" (no extensions, just plain UDP) and \"kitchen sink\" (tries to implement all defined extensions).  General-purpose libraries will have to cater to a wide variety of customers, so they'll implement everything.  Minimal implementations will be written in cases where a library can't be used (e.g. embedded systems, obscure programming languages) and \"it works\" is good enough.\r\n\r\nAdding a header bitfield system doesn't help minimal implementers who don't care about ECN or timestamps or whatever, but it does make implementation more complex for the \"kitchen sink\" implementer, who already has a full implementation of dynamic registration for QUIC compression.",
          "createdAt": "2021-12-06T23:09:42Z",
          "updatedAt": "2021-12-06T23:09:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've suggested to alternate options in #72. These both avoid all or some of the dynamic registration behavior, and also don't rely on flags fields. Thoughts are welcome!",
          "createdAt": "2021-12-10T00:06:10Z",
          "updatedAt": "2021-12-10T00:06:10Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOETZKbc5AJYg7",
      "title": "Options for avoiding context registration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/72",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "#71 discusses the fact that many/most extensions to CONNECT-UDP (and likely CONNECT-IP to a lesser degree) don\u2019t need to have dynamic context ID registration via capsules, and that mechanism may be overly complex and burdensome.\r\n\r\nI have two options for alternate designs I\u2019d like to propose that should simplify things.\r\n\r\nFirst, some basic assumptions:\r\n- We expect many extensions to be \u201cstatic\u201d \u2014 they will have a defined way to parse what they add to datagram payloads. This includes adding ECN fields, timestamps, or adding ICMP / PING messages.\r\n- We expect some extensions to need more \u201cdynamic\u201d state, specifically for compression of Datagram Payload fields, where we may not know all of the compression contexts at the start of the request.\r\n\r\nFor both of the options that I\u2019m proposing, I am suggesting that we use the mechanism for nesting extensions that Ben suggested at the last design team meeting \u2014 specifically, that an extension defines how to interpret the Datagram payload. If the extension is intended to be composable, it can include a \u201cnext payload\u201d VLI at the end which determines the type of the remainder of the payload.\r\n\r\nProtocols like CONNECT-UDP and CONNECT-IP would always use the VLI \u201c0\u201d to indicate their default Datagram Payload (UDP payload and IP packet, respectively).\r\n\r\nFor example, an ECN extension could define itself in one of the following ways:\r\n\r\nNot further composable:\r\n\r\n```\r\nDatagram {\r\n   Type (i), // VLI indicating that ECN extension is used\r\n   ECN flags (8),\r\n   UDP payload (..)\r\n}\r\n```\r\nFurther composable:\r\n\r\n```\r\nDatagram {\r\n   Type (i), // VLI indicating that ECN extension is used\r\n   ECN flags (8),\r\n   Next Type (i), // VLI indicating next extension type, 0 if it is UDP payload\r\n   (..)\r\n}\r\n```\r\n\r\nSome extension types, or course, don\u2019t make sense to compose, so they wouldn\u2019t define that ability.\r\n\r\nI think this kind of composability is preferable to trying to use flag fields and define an order, or trying to negotiated composability rules. It means spending extra VLIs when doing lots of composing, but I expect that to be a limited / minor impact, and one that is worth the simplicity.\r\n\r\nThe question, then, is what this Type / Context VLI at the start of a datagram is, and how it is allocated. Here are the two options I propose:\r\n\r\n### Option 1: Use Capsule Types\r\n\r\nThe VLI at the start of the datagram is a registered IANA value, which can be the same as the capsule type registry itself. Datagram starts with 0 for the protocol default (UDP body for CONNECT-UDP). For extensions, they use the registered capsule type ID that defines the extension used.\r\n\r\nWhen sending the header that negotiates support for capsules, each side sends an sf-list of sf-integers to indicate the capsule types / extensions they support:\r\n\r\n`Capsule-Protocol: 1, 2, 7`\r\n\r\nWhere in this example, we pretend the following values are defined:\r\n\r\n1 = ECN Extension\r\n2 = Timestamp extension\r\n7 = Compression\r\n\r\nIf your extension needs dynamic mappings, like IP compression, the datagram starts with a fixed value for the capsule that negotiates the extension (7 in this example), and capsules can negotiate a second VLI or something else that actually represents the dynamic mapping.\r\n\r\nPros:\r\n- Doesn\u2019t require capsules to register dynamic types; only extensions that need dynamic state need to use capsules at all.\r\n- Support for extensions is declared in headers, no there is no need to dynamically learning that an extension isn\u2019t supported.\r\n- An implementation receiving a datagram can know exactly what the format of the datagram is, without needing to look up per-request state.\r\n\r\nCons (pretty much all about size efficiency):\r\n- If there are many extension/capsule types, the VLI may go beyond one byte commonly, and thus bloat the datagram.\r\n- Dynamic extensions that create state, like compression, will use two VLIs in the datagram: one for the extension type, and one for the dynamic value. This also can bloat the datagram.\r\n\r\n### Option 2: Negotiate values in headers & capsules\r\n\r\nThe VLI at the start of the datagram is a context ID defined per request stream, but the ID can be allocated via request/response headers, not just capsules. This makes the mapping far less dynamic.\r\n\r\nWhen sending the header that negotiates support for capsules, each side sends an sf-dictionary of sf-integers to indicate the context IDs that they will use for various supported extensions:\r\n\r\n`Capsule-Protocol: ecn=1, timestamp=2`\r\n\r\nFor compression extensions that need dynamic state, they can allocated any context ID values not already allocated in the header via capsules:\r\n\r\n```\r\nREGISTER_COMPRESSION_CONTEXT {\r\n\tContext = 3,\r\n\tSource IP address = foo,\r\n\tDestination IP address = bar\r\n}\r\n```\r\n\r\nIf any context ID ever overlaps, this is treated as an error.\r\n\r\nPros:\r\n- Extensions only ever need one VLI at the start, for both static extensions and dynamic extensions that need capsule negotiation.\r\n- Most context IDs can be learned from headers, reducing the need for dynamic logic.\r\n- The initial VLI can pretty much always be just one byte, since each side can make sure to allocate low values.\r\n\r\nCons:\r\n- Datagram parsing requires some state management (looking at the mapping created by the headers or capsules), even when just using static extensions.",
      "createdAt": "2021-12-10T00:04:25Z",
      "updatedAt": "2021-12-14T01:08:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this proposal, it keeps the core CONNECT-UDP document simple while still enabling extension composability for extensions that desire it. In terms of allocation of the VLI, Option 2 sounds like a much better path forward than option 1.\r\n\r\nVarints exist to leverage the probabilistic imbalance, and if we send IANA-registered values in varints, we'll encourage folks to fight over low values which could lead to collisions. Also reusing the capsule type here doesn't make sense to me, these aren't capsules, they're datagram format types.",
          "createdAt": "2021-12-10T00:18:44Z",
          "updatedAt": "2021-12-10T00:18:44Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "What would happen in Proposal 2 if ECN and Timestamp had their context ID values reserved in an IANA registry, rather then being specified on the wire:\r\n\r\n> Capsule-Protocol: ecn, timestamp\r\n\r\nIf an extension is in use, its predefined code point is unavailable for dynamic purposes.  You only lose the ability to remap extension code points to shorter VLIs, which doesn't really matter until you have more than 62 code points.",
          "createdAt": "2021-12-10T01:35:44Z",
          "updatedAt": "2021-12-10T01:35:44Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@afrind Right, you could consider a hybrid with some fixed values and some dynamic ones. However, unless we defined a specific boundary (or a scheme like skipping every other number), I'd be a bit concerned about the two sides not agreeing on which of the values were available for dynamic allocation.  ",
          "createdAt": "2021-12-10T01:47:46Z",
          "updatedAt": "2021-12-10T01:47:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I like this direction.  Some variations:\r\n\r\n1. Simpler.  Instead of sf-dictionary[sf-int], how about just sf-list?\r\n```\r\nCapsule-Protocol: ecn, timestamp\r\n```\r\nThe indices are the IDs, starting at 1.  (Zero is reserved for the default format.)\r\n\r\n2. More compact: Allow parameters on static allocations (sf-params on sf-int):\r\n```\r\nCapsule-Protocol: 1; ecn=1, 2; ecn=2, 3; ecn=3, 4; timestamp\r\n```\r\nThis saves one byte of overhead for ECN.\r\n\r\nHaving both static and dynamic registrations in the same context ID space seems weird to me.  If we have dynamic registrations, then we don't need the header, so it's just additive complexity.\r\n\r\nThere's also some awkwardness around negotiation.  If negotiation also registers the context IDs, then it can't be used with a dynamic compression format, which can't be registered yet.  That means that when you attempt dynamic registration, you don't know if the peer supports this format at all, so we also need a dynamic rejection signal.\r\n\r\nIt might be cleaner to stick to purely static Type ID allocation, and move the dynamic allocation inside the relevant payload section, e.g.\r\n```\r\nCapsule-Protocol: ecn, timestamp, compress\r\n\r\nCapsule REGISTER_COMPRESSION_CONTEXT {\r\n  Compression-Context = 52,\r\n  Source IP address = foo,\r\n  Destination IP address = bar\r\n}\r\n\r\nTimestamp+ECN+Compression Datagram {\r\n  Type = 2\r\n  Timestamp = 87814829852\r\n  Type = 1\r\n  ECN = 2\r\n  Type = 3\r\n  Compression-Context = 52\r\n  Compressed-Payload = ...\r\n}\r\n```\r\nThis costs ~1 byte, but it avoids the situation of having multiple capsule types that are modifying a shared ID space.",
          "createdAt": "2021-12-10T02:36:33Z",
          "updatedAt": "2021-12-10T13:35:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "NONE",
          "body": "I also like the direction.\r\n\r\nIIUC, the approach is to let each side _declare_ the types that it would use and the IDs being used for each type. That declaration is being done using HTTP headers.\r\n\r\nIt makes sense to declare them in HTTP headers, because HTTP applications are required to process request / response headers before processing the payload, even when the payload arrives before the headers (due to reordering). To paraphrase, by using of headers, we can rely on existing mechanism to handle out-of-order delivery of DATAGRAM frames.\r\n\r\n@bemasc \r\n> 1. Simpler. Instead of sf-dictionary[sf-int], how about just sf-list?\r\n\r\n+1.\r\n\r\n> Having both static and dynamic registrations in the same context ID space seems weird to me. If we have dynamic registrations, then we don't need the header, so it's just additive complexity.\r\n\r\n+1.",
          "createdAt": "2021-12-10T02:45:52Z",
          "updatedAt": "2021-12-10T02:46:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bemasc Yeah the static only approach is essentially what I was trying to get at with option 1. I like how you express it too. ",
          "createdAt": "2021-12-10T02:49:56Z",
          "updatedAt": "2021-12-10T02:49:56Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> It might be cleaner to stick to purely static Type ID allocation, and move the dynamic allocation inside the relevant payload section\r\n\r\nThis has always made the most sense to me. \r\n\r\n> Capsule-Protocol: ecn, timestamp, compress\r\n\r\nJust to make sure I understand your example, `ecn` and `timestamp` are defined as \"further composable\" but `compress` is not?  Would most types register both a composable and non-composable code point?\r\n",
          "createdAt": "2021-12-10T03:28:57Z",
          "updatedAt": "2021-12-10T03:28:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Just to make sure I understand your example, ecn and timestamp are defined as \"further composable\" but compress is not? Would most types register both a composable and non-composable code point?\r\n\r\nYes, I think the compressed payload would not let itself be followed by another extension, since it is replacing the uncompressed default payload. So it can simply be the terminal payload of the datagram.",
          "createdAt": "2021-12-10T04:30:50Z",
          "updatedAt": "2021-12-10T04:30:50Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "> Just to make sure I understand your example, `ecn` and `timestamp` are defined as \"further composable\" but `compress` is not?\r\n\r\nYes.  Tommy's `Next Type` field in the format for `ECN` seems like a good way to think about this.\r\n\r\n> Would most types register both a composable and non-composable code point?\r\n\r\nNo, most types would only have one codepoint, and be intrinsically composable (header-like) or non-composable (body-like).",
          "createdAt": "2021-12-10T13:39:30Z",
          "updatedAt": "2021-12-10T13:39:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To write this up in the format before, I think this is what we're landing on:\r\n\r\n### Option 3: Determine values in header\r\n\r\nThe VLI at the start of the datagram is an ID defined per request stream to map to a single extension type that determines the datagram format, and is allocated by a header in the request. Extensions that need dynamic markers, like compression, define their own interior formats that can include compression contexts.\r\n\r\nWhen sending the header that negotiates support for capsules, the client sends an sf-list, with an sf-token for each extension it intends to use. Each extension is implicitly assigned an integer value, starting at 1, which is later used in the datagram as the VLI. The server includes a list of its supported extensions in its response; while the server may not support some values from the client, it does not change the integers assigned for use in datagrams.\r\n\r\nFor example, if the client sends this:\r\n\r\n`Capsule-Protocol: ecn, timestamp`\r\n\r\nECN is assigned `1`, and timestamp is assigned `2`.\r\n\r\nFor the (common) case where no extension is supported, the list simply includes one item, which is an sf-boolean instead of an sf-token:\r\n\r\n`Capsule-Protocol: ?1`\r\n\r\n(Alternatively we could define a different header for the extensions, but I think we should define that in h3-datagram?)\r\n\r\nPros:\r\n- The initial VLI will almost always be just one byte, since it is highly unlikely that the client will list more than 62 extensions in its request\r\n- Clients can start sending datagrams using extensions as soon as they send their request\r\n- No changing of the meaning of the first VLI after processing the request\r\n\r\nCons (minimal, IMO):\r\n- Extensions that use dynamic state, like compression, need to use another marker (like a VLI) for their context. This space overhead is minimal, however, especially given that the first VLI will essentially always be one byte only.\r\n- Datagram parsing requires remembering the values passed in the client request.",
          "createdAt": "2021-12-10T16:38:24Z",
          "updatedAt": "2021-12-10T16:38:24Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": ">  Each extension is implicitly assigned an integer value, starting at 1, which is later used in the datagram as the VLI. The server includes a list of its supported extensions in its response; while the server may not support some values from the client, it does not change the integers assigned for use in datagrams.\r\n\r\nThen I'm on option 4, everything else is the same as Option 3, but each extension has a code point allocated by its specification.  I can't see an advantage in Option 3 to having ecn having different code points per request depending on the order specified in a header.  Yes, it will cost another byte when we get to 62 extensions, but does anyone practically think we're going to get there?\r\n",
          "createdAt": "2021-12-10T16:48:13Z",
          "updatedAt": "2021-12-10T16:48:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One benefit of not having fixed numbers for the extensions is that we don't need to worry about a numbered registry across different protocols; we just can have a extension name registry.\r\n\r\nI think that it's certainly possible to hit more than 62 extensions total over the lifetime of the protocol, whereas its essentially impossible to hit that many for a given request.\r\n\r\nTurning the question around: what is the burden of having the values be determined by the request? The quarter stream ID is already dependent on the request, so it seems like you could populate all the information at the same time. ",
          "createdAt": "2021-12-10T17:06:58Z",
          "updatedAt": "2021-12-10T17:06:58Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "I would spell \"no extensions\" by omitting the header.\n\nUsing fixed values doesn't really simplify anything because we still need\nthe same header to negotiate support, so I think dynamic values are\nsensible (and avoid any concern about trying to get earlier registry\nentries).\n\nOn Fri, Dec 10, 2021, 11:48 AM afrind ***@***.***> wrote:\n\n> Each extension is implicitly assigned an integer value, starting at 1,\n> which is later used in the datagram as the VLI. The server includes a list\n> of its supported extensions in its response; while the server may not\n> support some values from the client, it does not change the integers\n> assigned for use in datagrams.\n>\n> Then I'm on option 4, everything else is the same as Option 3, but each\n> extension has a code point allocated by its specification. I can't see an\n> advantage in Option 3 to having ecn having different code points per\n> request depending on the order specified in a header. Yes, it will cost\n> another byte when we get to 62 extensions, but does anyone practically\n> think we're going to get there?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/72#issuecomment-991129153>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AABO3SLMUBSUFVDJWGZTN7DUQIVNRANCNFSM5JXZMM2A>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-12-10T17:09:59Z",
          "updatedAt": "2021-12-10T17:09:59Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> One benefit of not having fixed numbers for the extensions is that we don't need to worry about a numbered registry across different protocols; we just can have a extension name registry.\r\n\r\nWe have such registries for HTTP/2 and HTTP/3 frame types, and errors, etc.\r\n\r\n> I think that it's certainly possible to hit more than 62 extensions total over the lifetime of the protocol\r\n\r\nPossible yes.  Probable no.\r\n\r\n> Turning the question around: what is the burden of having the values be determined by the request? The quarter stream ID is already dependent on the request, so it seems like you could populate all the information at the same time.\r\n\r\nThe burden is in the receiver having to do a lookup to know how to parse the datagram.  We could have done this with QUIC too -- instead of giving each QUIC frame a code point, we could have the transport params negotiate the code points it wants for each frame.  Why didn't we do this?  It's slow and unnecessary.\r\n",
          "createdAt": "2021-12-10T17:11:37Z",
          "updatedAt": "2021-12-10T17:11:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "> I would spell \"no extensions\" by omitting the header.\r\n\r\nWe get this for free, which is neat. Per https://www.rfc-editor.org/rfc/rfc8941.html#section-3.1-6\r\n\r\n> An empty List is denoted by not serializing the field at all. This implies that fields defined as Lists have a default empty value.",
          "createdAt": "2021-12-10T17:13:52Z",
          "updatedAt": "2021-12-10T17:13:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The reason I left the header was that it was already around for saying \"I use capsules at all\", but if we use a different header or decide we don't need that original header, then yes an empty/omitted list works.",
          "createdAt": "2021-12-10T17:18:27Z",
          "updatedAt": "2021-12-10T17:18:27Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The burden is in the receiver having to do a lookup to know how to parse the datagram. We could have done this with QUIC too -- instead of giving each QUIC frame a code point, we could have the transport params negotiate the code points it wants for each frame. Why didn't we do this? It's slow and unnecessary.\r\n\r\nI think QUIC frames is arguably a bit different: QUIC frames can be parsed regardless of any other knowledge, already.  The payload of datagram frames, on the other hand, already requires that you understand the quarter-stream ID based on a request you've received. Since you have to wait to interpret this, this is essentially saying you use the request to interpret the first two octets of the datagram rather than just the first one octet.",
          "createdAt": "2021-12-10T17:20:35Z",
          "updatedAt": "2021-12-10T17:20:35Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> Since you have to wait to interpret this, this is essentially saying you use the request to interpret the first two octets of the datagram rather than just the first one octet.\r\n\r\nWaiting is ok.  Using another octet to figure out what to do is ok.  Allowing the peer to map the same semantics to  different octets for every request is the unnecessary part.  I don't see the value there.",
          "createdAt": "2021-12-10T19:30:07Z",
          "updatedAt": "2021-12-10T19:30:07Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "> The reason I left the header was that it was already around for saying \"I use capsules at all\", but if we use a different header or decide we don't need that original header, then yes an empty/omitted list works.\r\n\r\nOK.  My preference would be for `Capsule-Protocol = sh-boolean` and `Datagram-Formats = sh-list`.\r\n\r\nRegarding renumbering the formats: I think this is actually helpful, conceptually, because it makes it clearer that these formats have no meaning outside of their Request/Response context.  If you haven't seen the corresponding header value, there's no guarantee that you can even parse the datagram, and implementations should resist any temptation to try.",
          "createdAt": "2021-12-13T17:32:33Z",
          "updatedAt": "2021-12-13T17:37:10Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like `Datagram-Formats = sh-list` as an option.\r\n\r\nI also agree with @bemasc about the numbering being determined by the request. If we're already waiting for the request to be able to know the quarter stream ID, I don't think it's a burden to have the format numbering be based on state from that request.",
          "createdAt": "2021-12-13T18:51:55Z",
          "updatedAt": "2021-12-13T18:51:55Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's a very simple reduction to just have a static registry for formats, with no flags: #73 ",
          "createdAt": "2021-12-13T23:20:41Z",
          "updatedAt": "2021-12-13T23:20:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(To be clear, I'd probably prefer a dynamic setup)",
          "createdAt": "2021-12-14T00:32:08Z",
          "updatedAt": "2021-12-14T00:32:08Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Tommy. I've updated #70 so that HTTP headers can now be used to register context IDs. I think that makes it a lot simpler.",
          "createdAt": "2021-12-14T01:08:34Z",
          "updatedAt": "2021-12-14T01:08:34Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOETZKbc5AX8VR",
      "title": "Supporting Don't Fragment (or not)",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/74",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "An application that tunnels UDP may rely on certain properties or features of the socket that the proxy creates. The draft covers some of these but doesn't seem to mention the UDP fragmentation. TURN has a whole section on this https://www.rfc-editor.org/rfc/rfc8656.html#section-3.7\r\n\r\nQUIC, for example, requires that `UDP datagrams MUST NOT be fragmented at the IP layer` and recommends the Don't Fragment (DF) bit MUST be set if possible. \r\n\r\nSince a proxy is agnostic to the application protocol in use (I'm assuming that because we don't mention the [ALPN header](https://datatracker.ietf.org/doc/html/rfc7639) anywhere) perhaps CONNECT-UDP would benefit from a signal the client can send to the proxy to state it's DF preferences.  ",
      "createdAt": "2021-12-14T17:16:23Z",
      "updatedAt": "2021-12-15T00:43:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds like a worthwhile extension draft? I don't think it's required to have a functional CONNECT-UDP protocol",
          "createdAt": "2021-12-14T23:36:05Z",
          "updatedAt": "2021-12-14T23:36:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "One argument for doing it here is that one of the common uses of CONNECT-UDP will be to tunnel QUIC, and this is an obvious footgun in consideration of RFC 9000 requirements. \r\n\r\nThe opposite way to solve the problem could be to add MUST/SHOULD language about proxies setting DF by default. And then require an extension to signal to disable it. But this is solutionizing a bit.\r\n\r\nReally, I want to be able to write a client that can have consistent expectations about the way datagram payload gets sent on UDP. Otherwise when things go wrong I'm left guessing and I might not have the information that the proxy did. I could even live with text in this document that raises this as a consideration but punts on the problem.",
          "createdAt": "2021-12-14T23:51:18Z",
          "updatedAt": "2021-12-14T23:51:41Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "Note that this isn't just about setting `DF` in IPv4.  It's also about whether to apply sender fragmentation, in IPv6.\r\n\r\nI would be OK with declaring that all fragmentation is off by default, and leave it to extensions to turn it on.",
          "createdAt": "2021-12-14T23:57:31Z",
          "updatedAt": "2021-12-14T23:57:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Good point Ben!",
          "createdAt": "2021-12-15T00:08:55Z",
          "updatedAt": "2021-12-15T00:08:55Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd be OK with saying proxies MUST NOT explicitly add fragmentation and SHOULD set the DF bit. We can't say MUST set DF because not all operating systems allow setting the DF bit on UDP sockets.",
          "createdAt": "2021-12-15T00:30:09Z",
          "updatedAt": "2021-12-15T00:30:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "RFC 9000 says `In IPv4 [IPv4], the Don't Fragment (DF) bit MUST be set if possible, to prevent fragmentation on the path.`, not a fan?",
          "createdAt": "2021-12-15T00:34:28Z",
          "updatedAt": "2021-12-15T00:34:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "\"MUST ... if possible\" is the same as \"SHOULD\" for me, I don't much care between them.",
          "createdAt": "2021-12-15T00:43:59Z",
          "updatedAt": "2021-12-15T00:43:59Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDOETZKbc5CJ80Z",
      "title": "Define the syntax of connect-udp-version HTTP header field",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/78",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The doc has a development versioning header `connect-udp-version` but it omits the ABNF. The format is described as a list of values on request headers and a single item on response headers. I'm going to assume this is an sf-list, can we state that to avoid uncertainty?",
      "createdAt": "2022-01-21T00:23:20Z",
      "updatedAt": "2022-01-21T00:43:46Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4NjM2ODgx",
      "title": "Add tags for interop",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/18",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Adding tags for the hackathon interop matrix",
      "createdAt": "2020-11-10T17:08:45Z",
      "updatedAt": "2020-11-10T17:21:37Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "bf3be74710658b4e270a0b76fbe28cd87bf399e4",
      "headRepository": "tfpauly/draft-ietf-masque-connect-udp",
      "headRefName": "tfp/interop",
      "headRefOid": "800aca8af4e5ca348ea8c2bd477ea571829a0fe1",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NDMzNDg4",
          "commit": {
            "abbreviatedOid": "800aca8"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-10T17:21:37Z",
          "updatedAt": "2020-11-10T17:21:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzMDYwNDcy",
      "title": "Specify tunneling of ECN marks",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/30",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Resolves #29.\r\n\r\nOn a related note, the text in #performance talks about disabling congestion control on a \"connection,\" but I believe this is actually a per-endpoint decision. (The client could easily have more information than the proxy on the tunneled connections).",
      "createdAt": "2021-01-11T22:31:31Z",
      "updatedAt": "2021-03-05T22:43:06Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "a120b0e6b722c08537fa5f9486ce1339ba1fa099",
      "headRepository": "martinduke/draft-ietf-masque-connect-udp",
      "headRefName": "ecn-tunnel",
      "headRefOid": "f6ca61c49cd62d194049c8bca0bc64ee34d5a7ac",
      "closedAt": "2021-03-05T22:43:06Z",
      "mergedAt": "2021-03-05T22:43:06Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b0aad2eb8558d0f75a97dc272ce3c8ede96bdacb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1ODYyNzc3",
          "commit": {
            "abbreviatedOid": "a0c80ee"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-12T01:11:12Z",
          "updatedAt": "2021-01-12T01:16:38Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "There is no inner IP header in CONNECT-UDP, could we rephrase this sentence to make that clearer?",
              "createdAt": "2021-01-12T01:11:12Z",
              "updatedAt": "2021-01-12T21:45:06Z"
            },
            {
              "originalPosition": 10,
              "body": "Perhaps we should move this paragraph to that section to make things simpler?",
              "createdAt": "2021-01-12T01:11:58Z",
              "updatedAt": "2021-01-12T21:45:06Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\ncontrol the ECN codepoints on UDP packets the proxy sends to the server, nor can\r\n```",
              "createdAt": "2021-01-12T01:12:24Z",
              "updatedAt": "2021-01-12T21:45:06Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nproxies communicate the markings of each UDP packet from server to proxy.\r\n```",
              "createdAt": "2021-01-12T01:12:54Z",
              "updatedAt": "2021-01-12T21:45:06Z"
            },
            {
              "originalPosition": 19,
              "body": "This is hard to reason about, and I think I'm getting confused between this paragraph and the next. And the fact that a QUIC packet can carry multiple DATAGRAM frames makes things even harder. Could we instead say `A CONNECT-UDP proxy MUST ignore ECN bits in the IP header of UDP packets received from the server, and MUST NOT set the ECN bits on UDP packets it sends to the server.`",
              "createdAt": "2021-01-12T01:14:35Z",
              "updatedAt": "2021-01-12T21:45:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NzI2MjM5",
          "commit": {
            "abbreviatedOid": "4407666"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-12T21:44:24Z",
          "updatedAt": "2021-01-12T21:44:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\ncongestion control.\r\n```",
              "createdAt": "2021-01-12T21:44:24Z",
              "updatedAt": "2021-01-12T21:45:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NzI2NjEy",
          "commit": {
            "abbreviatedOid": "4407666"
          },
          "author": "martinduke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-12T21:44:59Z",
          "updatedAt": "2021-01-12T21:45:00Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nit sends to the server. These do not relate to the ECN markings of packets sent\r\n```",
              "createdAt": "2021-01-12T21:44:59Z",
              "updatedAt": "2021-01-12T21:45:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NDEwMzEz",
          "commit": {
            "abbreviatedOid": "f6ca61c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-01-13T16:37:07Z",
          "updatedAt": "2021-01-13T16:37:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5MjgxMTE1",
      "title": "Experiment with HTTP/3 frames",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/44",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is a thought experiment aimed at seeing whether using HTTP/3 frames for H3DGRAM and CONNECT-UDP makes sense. We're not planning on merging this as-is.",
      "createdAt": "2021-03-24T00:31:27Z",
      "updatedAt": "2021-09-14T16:20:04Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "b0aad2eb8558d0f75a97dc272ce3c8ede96bdacb",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "experiment_h3_frames",
      "headRefOid": "91cbb11cfe5660d2ec511913292181b5fb65abd7",
      "closedAt": "2021-09-10T19:58:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5MjMxMzk4",
          "commit": {
            "abbreviatedOid": "91cbb11"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-24T01:37:14Z",
          "updatedAt": "2021-03-24T01:37:15Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Since the HEADERS and REGISTER_DATAGRAM_FLOW_ID frames are delivered on the same stream, you have the luxury of ordering at your disposal. Since the CONNECT-UDP method is defined with `A payload within a CONNECT-UDP request message has no defined semantics`, you could state some strict frame ordering rules like \"REGISTER_DATAGRAM_FLOW_ID must come after the first HEADERS on a request stream in each direction\". I'm not suggesting that is necessary, just highligting something that came to mind.",
              "createdAt": "2021-03-24T01:37:14Z",
              "updatedAt": "2021-03-24T01:37:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkwMzIyMTc4",
      "title": "remove incorrect server registration echo",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/49",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This text was a mistake I made when converting from Datagram-Flow-Id to capsules.\r\n\r\nCloses #48.",
      "createdAt": "2021-07-15T01:21:34Z",
      "updatedAt": "2021-09-14T16:20:01Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "649890881aaa92548b5a0fb37a7622b409b281fd",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "noecho",
      "headRefOid": "ae227553f0a112bb80df9eaefc4df9426b0c326a",
      "closedAt": "2021-07-15T01:23:00Z",
      "mergedAt": "2021-07-15T01:23:00Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "9d56c9f4c59b82ff3a2ddbc8d71bbb52e941d4f4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIyNzEwOTA0",
      "title": "Can proceed without datagram",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/52",
      "state": "MERGED",
      "author": "martinduke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #51 ",
      "createdAt": "2021-08-30T18:16:53Z",
      "updatedAt": "2021-09-14T16:20:11Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "9d56c9f4c59b82ff3a2ddbc8d71bbb52e941d4f4",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "datagram-not-needed",
      "headRefOid": "aa4d2b7d3457381e554963fde19f04e33fe90139",
      "closedAt": "2021-09-10T02:00:06Z",
      "mergedAt": "2021-09-10T02:00:06Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "fc38dfba8859019f69cdeda4f53a4751fd658591"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQyMTA1MTM4",
          "commit": {
            "abbreviatedOid": "aa4d2b7"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for writing this up. I think this is the right solution. I'll leave this open for some time to see if anyone else would like to comment.\r\n\r\nTo add context: this text predates the creation of capsules, and now CONNECT-UDP works even if QUIC datagram frames aren't available. We'll want to pick a solution for https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/85 though. If the H3_DATAGRAM setting also covers capsules we might still need this text. But for now we can remove it.",
          "createdAt": "2021-08-30T21:55:01Z",
          "updatedAt": "2021-08-30T21:55:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxNzM1Mzc4",
      "title": "Clarify socket lifetime",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/53",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #46 ",
      "createdAt": "2021-09-10T20:25:58Z",
      "updatedAt": "2021-09-10T20:26:42Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "120e6621a3e6c2e5d68fc84c8fc6df215cdfa825",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "lifetime",
      "headRefOid": "0219e3cb295cedcc2f5f0469435cc1c43b5505af",
      "closedAt": "2021-09-10T20:26:40Z",
      "mergedAt": "2021-09-10T20:26:40Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "bee6d341a48524876ac71fce0e1ee0ad105efd5e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMxODQxMTUy",
      "title": "Switch to extended CONNECT",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/54",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on the list, there appears to be agreement to replace a custom method with extended CONNECT.\r\n\r\nCloses #23.\r\nCloses #33.",
      "createdAt": "2021-09-11T00:55:51Z",
      "updatedAt": "2021-09-13T16:37:07Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "bee6d341a48524876ac71fce0e1ee0ad105efd5e",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "extended_connect",
      "headRefOid": "07e8ab7c4033ada5791cd61be901781a43ad04de",
      "closedAt": "2021-09-11T16:19:15Z",
      "mergedAt": "2021-09-11T16:19:14Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "15038386af956e910ab08573998bc4232aacd71c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxODc2OTI5",
          "commit": {
            "abbreviatedOid": "6f39178"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-09-11T02:23:26Z",
          "updatedAt": "2021-09-11T02:40:11Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "As a note, I was finding that annotating sections this way was causing errors in the xml submission when trying to submit DATAGRAM. ",
              "createdAt": "2021-09-11T02:23:26Z",
              "updatedAt": "2021-09-11T02:40:11Z"
            },
            {
              "originalPosition": 57,
              "body": "\n```suggestion\n(such as HTTP/1.1), so any reference to \"stream\" in this document\n```",
              "createdAt": "2021-09-11T02:24:24Z",
              "updatedAt": "2021-09-11T02:40:11Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\nrepresents the entire connection.\n```\n",
              "createdAt": "2021-09-11T02:24:33Z",
              "updatedAt": "2021-09-11T02:40:11Z"
            },
            {
              "originalPosition": 75,
              "body": "Hm, I think if we're defining variables in the template, it should look more like what DoH uses, and what the URI template RFC lays out. \n\n```suggestion\nhttps://proxy.example.org:4443/masque{?target_host,target_port}\n```\n",
              "createdAt": "2021-09-11T02:31:55Z",
              "updatedAt": "2021-09-11T02:40:11Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\nrespond to the request without waiting for a packet from the target.\n```\n",
              "createdAt": "2021-09-11T02:35:22Z",
              "updatedAt": "2021-09-11T02:40:11Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\nA successful response (as defined in {{resp1}} and {{resp23}}) indicates that\n```\n",
              "createdAt": "2021-09-11T02:35:46Z",
              "updatedAt": "2021-09-11T02:40:11Z"
            },
            {
              "originalPosition": 140,
              "body": "I think we also need to mention that if hostname resolution is required, the proxy MUST do that before responding, and if there is an error SHOULD send it back via a proxy-status header. ",
              "createdAt": "2021-09-11T02:37:21Z",
              "updatedAt": "2021-09-11T02:40:11Z"
            },
            {
              "originalPosition": 159,
              "body": "As a nit, I think that connect-udp would be a better token. I don't think masque will make it clearer long term. ",
              "createdAt": "2021-09-11T02:39:57Z",
              "updatedAt": "2021-09-11T02:40:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxODkxODU3",
          "commit": {
            "abbreviatedOid": "6f39178"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks!",
          "createdAt": "2021-09-11T05:35:35Z",
          "updatedAt": "2021-09-11T05:58:39Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Apparently it's supposed to work if it's listed in the normative section at the top. I'll double check though",
              "createdAt": "2021-09-11T05:35:35Z",
              "updatedAt": "2021-09-11T05:58:39Z"
            },
            {
              "originalPosition": 75,
              "body": "Not necessarily, that would also be valid but so is this example. The example you describe would force the query parameter to be equal to the variable name, whereas the current example shows that you can pick custom query parameters",
              "createdAt": "2021-09-11T05:38:41Z",
              "updatedAt": "2021-09-11T05:58:39Z"
            },
            {
              "originalPosition": 159,
              "body": "Let's save that bikeshed for the bikeshed party with everyone around :P",
              "createdAt": "2021-09-11T05:41:33Z",
              "updatedAt": "2021-09-11T05:58:39Z"
            },
            {
              "originalPosition": 140,
              "body": "Good point, done.",
              "createdAt": "2021-09-11T05:58:18Z",
              "updatedAt": "2021-09-11T05:58:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxOTIyMDU1",
          "commit": {
            "abbreviatedOid": "13105df"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-11T14:15:06Z",
          "updatedAt": "2021-09-11T14:15:06Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Okay. I have a preference for the form I suggested, so there would be a consistent variable name in the URI. ",
              "createdAt": "2021-09-11T14:15:06Z",
              "updatedAt": "2021-09-11T14:15:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxOTIyMDg2",
          "commit": {
            "abbreviatedOid": "13105df"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-11T14:15:33Z",
          "updatedAt": "2021-09-11T14:15:33Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Okay, I will raise an issue then for that bike shed :)",
              "createdAt": "2021-09-11T14:15:33Z",
              "updatedAt": "2021-09-11T14:15:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUxOTMwMDI1",
          "commit": {
            "abbreviatedOid": "07e8ab7"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-11T16:17:58Z",
          "updatedAt": "2021-09-11T16:17:58Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Fair enough, I've added that as another example line so people see it as an option",
              "createdAt": "2021-09-11T16:17:58Z",
              "updatedAt": "2021-09-11T16:17:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyOTY0MjI4",
          "commit": {
            "abbreviatedOid": "07e8ab7"
          },
          "author": "enygren",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-13T16:22:20Z",
          "updatedAt": "2021-09-13T16:22:20Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "A new issue since already merged, but would this be better as a .well-known URI for the default template?",
              "createdAt": "2021-09-13T16:22:20Z",
              "updatedAt": "2021-09-13T16:22:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyOTc5MDg3",
          "commit": {
            "abbreviatedOid": "07e8ab7"
          },
          "author": "enygren",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-13T16:36:54Z",
          "updatedAt": "2021-09-13T16:36:54Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Opened #56 ",
              "createdAt": "2021-09-13T16:36:54Z",
              "updatedAt": "2021-09-13T16:36:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUyOTc5Mjk4",
          "commit": {
            "abbreviatedOid": "07e8ab7"
          },
          "author": "enygren",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-13T16:37:07Z",
          "updatedAt": "2021-09-13T16:37:07Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Opened #56 ",
              "createdAt": "2021-09-13T16:37:07Z",
              "updatedAt": "2021-09-13T16:37:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOETZKbc4rvN7_",
      "title": "React to HTTP Datagram extensibility rework",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/60",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR pairs with the corresponding HTTP Datagram PR:\r\nhttps://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/91\r\n\r\n[Rendered view of this PR here](https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/reworked_h3dgram_ext/draft-ietf-masque-connect-udp.html).",
      "createdAt": "2021-09-14T15:33:53Z",
      "updatedAt": "2021-09-21T00:31:22Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "15038386af956e910ab08573998bc4232aacd71c",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "reworked_h3dgram_ext",
      "headRefOid": "baf2c192f90d506500a89a11543b56003cfe7246",
      "closedAt": "2021-09-21T00:31:19Z",
      "mergedAt": "2021-09-21T00:31:19Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "a798e789a07571fc07b9d9bffab8fb93c29b0127"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "PR_kwDOETZKbc4s2xlO",
      "title": "Rename token to connect-udp",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/61",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #59 ",
      "createdAt": "2021-10-06T21:49:09Z",
      "updatedAt": "2021-10-06T21:50:31Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "cdce7eb2e49fb32ce1cb57e88a453bce96106fa8",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "token_bikeshed",
      "headRefOid": "442f1eb860718bb384dd5b13dda5ac7ab5897d36",
      "closedAt": "2021-10-06T21:50:20Z",
      "mergedAt": "2021-10-06T21:50:20Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "280f5ae34688467b73b073b2f67350510080e844"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "PR_kwDOETZKbc4s27Bv",
      "title": "Add MTU considerations",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/62",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #40.",
      "createdAt": "2021-10-06T22:13:21Z",
      "updatedAt": "2021-10-06T22:14:10Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "5328503aa3c4806ff13fa6263db10b090126dd80",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "mtu_considerations",
      "headRefOid": "12cc4106b7a4448fb9924f6969c0e42fc45e2bec",
      "closedAt": "2021-10-06T22:14:07Z",
      "mergedAt": "2021-10-06T22:14:07Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "afecf4f90130c55b20a651a52e36edc6b1c208df"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 63,
      "id": "PR_kwDOETZKbc4s2-AQ",
      "title": "Proxies should behave",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/63",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #31 ",
      "createdAt": "2021-10-06T22:21:21Z",
      "updatedAt": "2021-10-06T22:24:39Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "afecf4f90130c55b20a651a52e36edc6b1c208df",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "behave",
      "headRefOid": "067c0c5adf036a1e0fa1874773d7879673f64303",
      "closedAt": "2021-10-06T22:24:36Z",
      "mergedAt": "2021-10-06T22:24:35Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b5809092b68358d31008056db678e92424689933"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOETZKbc4uF1AK",
          "commit": {
            "abbreviatedOid": "067c0c5"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-06T22:23:46Z",
          "updatedAt": "2021-10-06T22:23:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "PR_kwDOETZKbc4vKXM-",
      "title": "First PR for 2021 Design Team",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/70",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR mainly tracks the changes in the [corresponding HTTP Datagrams PR](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/pull/124) and moves Context IDs to CONNECT-UDP.\r\n\r\nNote that this PR is against the design team consensus branch, not main.\r\n\r\n[Rendered view of this PR](https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/payload_varint/draft-ietf-masque-connect-udp.html).\r\n[Rendered diff with the design team consensus branch](https://www.ietf.org/rfcdiff?url1=https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/draft-ietf-masque-connect-udp.txt&url2=https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/payload_varint/draft-ietf-masque-connect-udp.txt).",
      "createdAt": "2021-11-30T02:26:03Z",
      "updatedAt": "2022-01-13T23:00:11Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "2021_design_team_consensus",
      "baseRefOid": "3694ca21e323dd84c0c721e18b9972ca7bd90e28",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "payload_varint",
      "headRefOid": "1163e2c330bd85e3e43a84ab24ae4b265b1c580b",
      "closedAt": "2022-01-13T23:00:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "This requires that all extensions to CONNECT-UDP use dynamic context allocation.  I'm not convinced dynamic context allocation is required for the currently known CONNECT-UDP extensions.  I know it was discussed yesterday and I think the thrust of the argument centered around composability of extensions, but it would help me if the reasoning could be written down.\r\n\r\nI'd also like it to be possible to write an extension that uses the varint statically -- eg my client and my server support an extension and I do not need to send a capsule in order to use it.  This could either mean the varint is always interpreted statically, and dynamic context identifiers would be in another varint, or we carve the varint into static and dynamic spaces.",
          "createdAt": "2021-11-30T17:29:25Z",
          "updatedAt": "2021-11-30T17:29:25Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "@afrind\r\n> my client and my server support an extension and I do not need to send a capsule in order to use it\r\n\r\nThis seems like it is out of scope?  If your client and server have out-of-band knowledge of each other beyond \"this is a CONNECT-UDP URI template\", you're no longer confined by any IETF standard, and you can do whatever you want.",
          "createdAt": "2021-11-30T17:35:36Z",
          "updatedAt": "2021-11-30T17:35:36Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> This seems like it is out of scope? \r\n\r\nSorry, I narrowed my example too far.  My point is that static interpretation of the varint yields a much simpler design for an ECN extension, or the timestamp extension, or even both combined.  ",
          "createdAt": "2021-11-30T18:08:28Z",
          "updatedAt": "2021-11-30T18:08:28Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "We can also move this discussion to an issue, if that's preferred.",
          "createdAt": "2021-11-30T18:15:39Z",
          "updatedAt": "2021-11-30T18:15:39Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Creating an issue for this sounds good. I'm not sure I see value in the \"I'd rather not have to send a capsule\" scenario, given how cheap capsules are.",
          "createdAt": "2021-11-30T19:16:07Z",
          "updatedAt": "2021-11-30T19:16:07Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Opened https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/71",
          "createdAt": "2021-11-30T19:30:34Z",
          "updatedAt": "2021-11-30T19:30:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this PR in favor of #75 ",
          "createdAt": "2022-01-13T23:00:11Z",
          "updatedAt": "2022-01-13T23:00:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOETZKbc4w1iWD",
          "commit": {
            "abbreviatedOid": "b04a5f2"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T17:24:13Z",
          "updatedAt": "2021-11-30T17:24:14Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I don't think this is how timestamps or registration should work, so I don't think we should have this example here, at least not in this form.",
              "createdAt": "2021-11-30T17:24:14Z",
              "updatedAt": "2021-11-30T17:24:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4w1-hi",
          "commit": {
            "abbreviatedOid": "b04a5f2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T19:17:01Z",
          "updatedAt": "2021-11-30T19:17:01Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Can you propose an alternative? It's unclear to me why you don't like this example.",
              "createdAt": "2021-11-30T19:17:01Z",
              "updatedAt": "2021-11-30T19:17:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4w2CWQ",
          "commit": {
            "abbreviatedOid": "b04a5f2"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T19:33:40Z",
          "updatedAt": "2021-11-30T19:33:40Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Proposal [here](https://bemasc.github.io/h3-datagram-ping/bemasc-timestamp-designteam/draft-schwartz-masque-h3-datagram-ping.html#name-timestamp)",
              "createdAt": "2021-11-30T19:33:40Z",
              "updatedAt": "2021-11-30T19:33:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4w2ErA",
          "commit": {
            "abbreviatedOid": "b04a5f2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T19:43:38Z",
          "updatedAt": "2021-11-30T19:43:39Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "That's a cool way to do timestamps, but it's too complex for illustration purposes - I'd much rather keep the example in this appendix simple",
              "createdAt": "2021-11-30T19:43:39Z",
              "updatedAt": "2021-11-30T19:43:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4w2GLA",
          "commit": {
            "abbreviatedOid": "b04a5f2"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T19:50:05Z",
          "updatedAt": "2021-11-30T19:50:06Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Agreed, but the example shouldn't conflict with any actual proposals.",
              "createdAt": "2021-11-30T19:50:05Z",
              "updatedAt": "2021-11-30T19:50:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4w2HPA",
          "commit": {
            "abbreviatedOid": "b04a5f2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T19:54:34Z",
          "updatedAt": "2021-11-30T19:54:34Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Can you propose another synthetic extension for here that's not timestamps?",
              "createdAt": "2021-11-30T19:54:34Z",
              "updatedAt": "2021-11-30T19:54:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4w2vd2",
          "commit": {
            "abbreviatedOid": "b04a5f2"
          },
          "author": "achernya",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-30T23:20:04Z",
          "updatedAt": "2021-11-30T23:20:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOETZKbc4xh6of",
          "commit": {
            "abbreviatedOid": "3d50451"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T03:16:04Z",
          "updatedAt": "2021-12-14T03:16:05Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n{: #dgram-format title=\"UDP Proxying HTTP Datagram Format\"}\r\n```",
              "createdAt": "2021-12-14T03:16:04Z",
              "updatedAt": "2021-12-14T03:16:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOETZKbc4vyoOn",
      "title": "Static datagram format registry proposal",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/73",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "No dynamic fields/flags in the base CONNECT-UDP spec, let extensions define headers / flags / dynamic contexts.",
      "createdAt": "2021-12-13T23:19:58Z",
      "updatedAt": "2022-01-13T23:00:24Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "3694ca21e323dd84c0c721e18b9972ca7bd90e28",
      "headRepository": "tfpauly/draft-ietf-masque-connect-udp",
      "headRefName": "patch-1",
      "headRefOid": "8a59315050680f1ec890002bd029c6675214a9a9",
      "closedAt": "2022-01-13T23:00:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "My question is: if we agree on this, is this sufficient for us to close the design team?  Or do we also need to establish how we intend to enable metadata, extensions, and alternative formats?",
          "createdAt": "2021-12-14T17:46:58Z",
          "updatedAt": "2021-12-14T17:46:58Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this is sufficient to close the team, if we agree. We don't need to design all future extensions. Remember, the design team was about H3 datagrams, not CONNECT-UDP and CONNECT-IP. I think we only need to provide a foundation that allows for extensibility.",
          "createdAt": "2021-12-14T19:04:15Z",
          "updatedAt": "2021-12-14T19:04:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "In terms of process, the design team doesn't need to solve all the open questions about extensibility. The design team will be done when we have a solution that we believe allows enough future extensibility.\r\n\r\nMy personal read is that either #70 or #73 (or other potential options) fit the bill here.",
          "createdAt": "2021-12-15T00:37:21Z",
          "updatedAt": "2021-12-15T00:37:21Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "This design is good for simple extensions and provides an unobtrusive mechanism to use a dynamic context extension at a cost of one byte.  It's weak in providing a general mechanism to handle extension composability, and kicks that down the road.  Maybe that's fine?  We have several workable schemes for composability (flags, next-type, contexts), so we could defer to extension authors to pick.",
          "createdAt": "2021-12-15T01:06:11Z",
          "updatedAt": "2021-12-15T01:06:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this PR in favor of #76",
          "createdAt": "2022-01-13T23:00:24Z",
          "updatedAt": "2022-01-13T23:00:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 75,
      "id": "PR_kwDOETZKbc4w-WU7",
      "title": "Dynamic allocation of contexts",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/75",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is one potential design for the identifier at the start of the CONNECT-UDP datagram payload.\r\n\r\nNote that this PR is against the design team consensus branch, not main.\r\n\r\n[Rendered view of this PR](https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/context_id/draft-ietf-masque-connect-udp.html).\r\n[Rendered diff with the design team consensus branch](https://www.ietf.org/rfcdiff?url1=https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/2021_design_team_consensus/draft-ietf-masque-connect-udp.txt&url2=https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/context_id/draft-ietf-masque-connect-udp.txt).",
      "createdAt": "2022-01-13T22:59:21Z",
      "updatedAt": "2022-01-20T23:28:50Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "2021_design_team_consensus",
      "baseRefOid": "626b55dfaa6e31052006c1ff6ebce9a1f3d4e2b7",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "context_id",
      "headRefOid": "2875f1ae190d3c541a1518e2dcb004b1e241abb1",
      "closedAt": "2022-01-20T23:28:50Z",
      "mergedAt": "2022-01-20T23:28:49Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "f34fb0fe661b6929f0e23a992d0dcb57a33c4de3"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "During the HTTP Datagrams Design Team meeting on 2022-01-20, we reached consensus to move forward with the dynamic approach, so I'm merging this PR.",
          "createdAt": "2022-01-20T23:28:45Z",
          "updatedAt": "2022-01-20T23:28:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOETZKbc4yzb46",
          "commit": {
            "abbreviatedOid": "3c42f04"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T23:21:16Z",
          "updatedAt": "2022-01-13T23:21:16Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Pre-existing text, but this is *format*, not semantics.  The semantics follow (i.e., meetings will continue until morale improves).",
              "createdAt": "2022-01-13T23:21:16Z",
              "updatedAt": "2022-01-13T23:21:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4yzcu_",
          "commit": {
            "abbreviatedOid": "2875f1a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T23:27:44Z",
          "updatedAt": "2022-01-13T23:27:44Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Agreed. Fixed in the 2021_design_team_consensus branch",
              "createdAt": "2022-01-13T23:27:44Z",
              "updatedAt": "2022-01-13T23:27:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOETZKbc4w-WbA",
      "title": "Static allocation of contexts",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/76",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is one potential design for the identifier at the start of the CONNECT-UDP datagram payload.\r\n\r\n(for the record, I personally strongly prefer the dynamic approach from #75)\r\n\r\nNote that this PR is against the design team consensus branch, not main.\r\n\r\n[Rendered view of this PR](https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/static/draft-ietf-masque-connect-udp.html).\r\n[Rendered diff with the design team consensus branch](https://www.ietf.org/rfcdiff?url1=https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/2021_design_team_consensus/draft-ietf-masque-connect-udp.txt&url2=https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/static/draft-ietf-masque-connect-udp.txt).",
      "createdAt": "2022-01-13T22:59:42Z",
      "updatedAt": "2022-01-20T23:28:40Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "2021_design_team_consensus",
      "baseRefOid": "626b55dfaa6e31052006c1ff6ebce9a1f3d4e2b7",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "static",
      "headRefOid": "09647d7ed4c44484033be14b12986a5b5a4c79a8",
      "closedAt": "2022-01-20T23:28:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "During the HTTP Datagrams Design Team meeting on 2022-01-20, we reached consensus to move forward with the dynamic approach, so I'm closing this PR in favor of #75.",
          "createdAt": "2022-01-20T23:28:40Z",
          "updatedAt": "2022-01-20T23:28:40Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 77,
      "id": "PR_kwDOETZKbc4xWs8x",
      "title": "CONNECT-UDP: 2021 Design Team Consensus",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/77",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR represents the consensus of the 2021 MASQUE Design Team.\r\n\r\n[Rendered view of this PR](https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/2021_design_team_consensus/draft-ietf-masque-connect-udp.html).\r\n[Rendered diff with the editor's copy](https://www.ietf.org/rfcdiff?url1=https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/draft-ietf-masque-connect-udp.txt&url2=https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/2021_design_team_consensus/draft-ietf-masque-connect-udp.txt).\r\n\r\ncc @afrind @LPardue @MikeBishop @martinthomson @vasilvv @ekr @achernya @bemasc @tfpauly @ihlar\r\n\r\nFixes #71 \r\nFixes #72 ",
      "createdAt": "2022-01-21T00:21:59Z",
      "updatedAt": "2022-01-27T22:24:37Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "main",
      "baseRefOid": "3694ca21e323dd84c0c721e18b9972ca7bd90e28",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "headRefName": "2021_design_team_consensus",
      "headRefOid": "144847a47b650f4e3128058eb59262e27b909037",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOETZKbc4zMn8H",
          "commit": {
            "abbreviatedOid": "f34fb0f"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM, thank you!",
          "createdAt": "2022-01-21T00:44:49Z",
          "updatedAt": "2022-01-21T00:44:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOETZKbc4zRFBK",
          "commit": {
            "abbreviatedOid": "f34fb0f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-21T23:28:46Z",
          "updatedAt": "2022-01-21T23:28:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOETZKbc4zU8-o",
          "commit": {
            "abbreviatedOid": "f34fb0f"
          },
          "author": "bemasc",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-24T15:34:55Z",
          "updatedAt": "2022-01-24T15:43:17Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nodd-numbered context IDs are server-initiated. Extensions can use any\r\n```\r\n\r\nI think it could be valuable to register IDs out of order.  Unless we have some compelling reason to require registration in-order, I would prefer to make it clearer that this is allowed.\r\n\r\n(I think composition is likely to work by first registering the components, and then constructing the composition using the components by ID.  Since the composition is the one we care about, we don't want to waste short IDs on the components that will not actually be used independently.)",
              "createdAt": "2022-01-24T15:34:55Z",
              "updatedAt": "2022-01-24T15:43:17Z"
            },
            {
              "originalPosition": 105,
              "body": "I would appreciate some clarification on whether a single extension is expected to offer _both_ registration mechanisms.\r\n\r\nIf most extensions are expected to support both, I think we should consider adding some standards development guidance to minimize duplicated effort (e.g. registration capsule contents should be exactly the header value).",
              "createdAt": "2022-01-24T15:41:23Z",
              "updatedAt": "2022-01-24T15:43:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zVFys",
          "commit": {
            "abbreviatedOid": "f34fb0f"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T15:59:55Z",
          "updatedAt": "2022-01-24T15:59:56Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I think some guidance would be useful but it would make most sense to put it alongside the Context ID definition in https://ietf-wg-masque.github.io/draft-ietf-masque-connect-udp/2021_design_team_consensus/draft-ietf-masque-connect-udp.html#section-4\r\n\r\nI don't think that needs to block this PR but can instead be done as a follow up WG item.",
              "createdAt": "2022-01-24T15:59:56Z",
              "updatedAt": "2022-01-24T15:59:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zVWe7",
          "commit": {
            "abbreviatedOid": "909e718"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T16:40:50Z",
          "updatedAt": "2022-01-24T16:40:50Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "During the last design team meeting, we reached consensus that extension composability should be addressed by the working group as a whole, instead of as part of the design team efforts. When we do look into this as a working group, I'm fairly confident that the appendix about extensions will get rewritten. That'll be the best time to discuss what guidance we want to provide in terms of whether a given extension should offer both registration mechanisms. All this to say I agree with Lucas, let's handle this as a follow up WG item - @bemasc feel free to file an issue to make sure this is tracked.",
              "createdAt": "2022-01-24T16:40:50Z",
              "updatedAt": "2022-01-24T16:40:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zVt0X",
          "commit": {
            "abbreviatedOid": "909e718"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T17:58:16Z",
          "updatedAt": "2022-01-24T22:01:11Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "possibly with different semantics as well.",
              "createdAt": "2022-01-24T17:58:16Z",
              "updatedAt": "2022-01-24T22:01:11Z"
            },
            {
              "originalPosition": 59,
              "body": "Don't we want to allow buffering Datagrams with an unknown context ID for a period of time as well?",
              "createdAt": "2022-01-24T17:59:23Z",
              "updatedAt": "2022-01-24T22:01:11Z"
            },
            {
              "originalPosition": 99,
              "body": "Is this the only instance of the phrase `allocation service` now?  I don't see a reference in the context-id section.",
              "createdAt": "2022-01-24T21:33:40Z",
              "updatedAt": "2022-01-24T22:01:11Z"
            },
            {
              "originalPosition": 101,
              "body": "This sentence seems like it belongs in the more normative section rather than examples.",
              "createdAt": "2022-01-24T21:34:31Z",
              "updatedAt": "2022-01-24T22:01:11Z"
            },
            {
              "originalPosition": 125,
              "body": "Would it be more clear to say \"server endpoints that understand\", and the also mention that the client also declares it's ability to handle and parse those datagrams by sending the header?\r\n\r\nAnd perhaps s/ignore/drop/ ?",
              "createdAt": "2022-01-24T21:37:03Z",
              "updatedAt": "2022-01-24T22:01:11Z"
            },
            {
              "originalPosition": 134,
              "body": "We were starting to bikeshed on the format of these headers in the last design team meeting.  Did we resolve that this is the preferred format, or are we punting back to the WG?",
              "createdAt": "2022-01-24T21:38:27Z",
              "updatedAt": "2022-01-24T22:01:11Z"
            },
            {
              "originalPosition": 34,
              "body": "Do we want to include in the draft any of our rationale behind this design choice (more compact encodings for extensions with per-request state and extension composition)?",
              "createdAt": "2022-01-24T21:43:51Z",
              "updatedAt": "2022-01-24T22:01:11Z"
            },
            {
              "originalPosition": 125,
              "body": "Have we considered the possibility of an extension with unidirectional semantics -- eg: one that an endpoint wishes to send but does not want to or cannot receive, or vice versa?  This design requires anyone wishing to send an extension be willing to accept it as well.  I don't really love splitting the context-ID space 4 ways, but we could.",
              "createdAt": "2022-01-24T21:59:08Z",
              "updatedAt": "2022-01-24T22:01:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zW55N",
          "commit": {
            "abbreviatedOid": "909e718"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Needs refinement, but I don't see any problems with the approach that are strong or fundamental enough to object to the general direction.\r\n\r\nTook a lot of work to arrive at \"stick a varint at the front\", but I can't say that the process had no value.",
          "createdAt": "2022-01-24T23:53:27Z",
          "updatedAt": "2022-01-25T00:27:41Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "You need to mention varint encoding here or people will complain about this not being byte-aligned.\r\n\r\n```suggestion\r\nContext IDs are 62-bit integers (0 to 2<sup>62</sup>-1) using the variable-length defined in {{Section ?? of QUIC}}. The context ID value of\r\n```",
              "createdAt": "2022-01-24T23:53:27Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n0 is reserved for UDP payloads, while non-zero values are dynamically\r\n```",
              "createdAt": "2022-01-24T23:53:38Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 34,
              "body": "I think that \"client-initiated\" is subtly wrong.  Even-numbered context IDs are reserved for allocation by clients and odd-numbered context IDs are reserved for servers.",
              "createdAt": "2022-01-24T23:54:39Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\navailable context ID for their own purposes. Once allocated, any\r\n```",
              "createdAt": "2022-01-24T23:55:06Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nthe context ID namespace is tied to a given HTTP request: it is possible for a\r\ncontext ID with the same numeric value to be simultaneously assigned\r\ndifferent semantics in distinct requests.\r\n```",
              "createdAt": "2022-01-24T23:57:05Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 52,
              "body": "It might be worth including the Quarter Stream ID here for completeness, or at least mentioning it in context.  I know that you are only defining the payload here, but a common failing in making specifications comprehensible is a lack of that sort of explanatory context.",
              "createdAt": "2022-01-24T23:58:33Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 99,
              "body": "Yeah, I think that you can drop the concept and simply talk about the endpoint just picking a context ID to assign.",
              "createdAt": "2022-01-24T23:59:49Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 38,
              "body": "Is there any constraints on allocation?  As a client, can I perform random allocations from the space?  (yes?) If I allocate 2^62-1 as a server, does that mean that all previous values are taken? (no?) What if a peer attempts to overload my allocation table? (suck it? we'll not be making it easy to consume multiple allocations anyway ...?)",
              "createdAt": "2022-01-25T00:03:23Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 119,
              "body": "This definitely needs to include the context ID.  As an example, the more context (no pun intended) the better.",
              "createdAt": "2022-01-25T00:04:08Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 110,
              "body": "House style doesn't use \"us\" or \"we\".\r\n\r\n```suggestion\r\nAs an example, take an extension that conveys the time at which a UDP\r\n```",
              "createdAt": "2022-01-25T00:04:54Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 122,
              "body": "It might pay to prefix this with \"Example-\" in order to (maybe) avoid a potential misunderstanding about whether this is a real thing.",
              "createdAt": "2022-01-25T00:05:40Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 174,
              "body": "I find this \"low context IDs\" thing to be a little bit of a non-sequitur.  You haven't established why composition might be useful or important, but now you are jumping straight to optimizing for size.  This section probably needs a bit more context.",
              "createdAt": "2022-01-25T00:08:10Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            },
            {
              "originalPosition": 91,
              "body": "I feel that these extensions are a little too well formed to serve well as extensions.  They read far too much like specifications, which might be misleading or confusing.\r\n\r\nIf the goal is to guide future protocol designers, that guidance can be provided as pure text.  Including \"grammar\" (illustrations really, if I stick to my position there) isn't necessary to convey the necessary meaning.",
              "createdAt": "2022-01-25T00:25:40Z",
              "updatedAt": "2022-01-25T00:27:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zW6EY",
          "commit": {
            "abbreviatedOid": "909e718"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T23:54:43Z",
          "updatedAt": "2022-01-25T00:28:21Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Agreed, added a clause.",
              "createdAt": "2022-01-24T23:54:43Z",
              "updatedAt": "2022-01-25T00:28:21Z"
            },
            {
              "originalPosition": 34,
              "body": "I don't think we need rationale for every single design decision, it'll make the document harder to read. RFC 9000 doesn't explain the rationale for client vs server-initiated streams",
              "createdAt": "2022-01-24T23:56:59Z",
              "updatedAt": "2022-01-25T00:28:21Z"
            },
            {
              "originalPosition": 101,
              "body": "Agreed, moved.",
              "createdAt": "2022-01-25T00:01:26Z",
              "updatedAt": "2022-01-25T00:28:21Z"
            },
            {
              "originalPosition": 59,
              "body": "That was an oversight, fixed.",
              "createdAt": "2022-01-25T00:01:41Z",
              "updatedAt": "2022-01-25T00:28:21Z"
            },
            {
              "originalPosition": 99,
              "body": "That was also an oversight, fixed.",
              "createdAt": "2022-01-25T00:08:56Z",
              "updatedAt": "2022-01-25T00:28:21Z"
            },
            {
              "originalPosition": 134,
              "body": "We decided to punt registration and extension composability back to the WG",
              "createdAt": "2022-01-25T00:09:54Z",
              "updatedAt": "2022-01-25T00:28:21Z"
            },
            {
              "originalPosition": 125,
              "body": "I've clarified the text about this specific client-initiated extension example.\r\n\r\nHowever, we don't need to do anything else for unidirectional extensions. Such an extension could easily say that its registration is unidirectional, and that sending in the other direction is not allowed. There's no reason to split the namespace - QUIC did that because a bidirectional stream has a more complex state machine, and bidirectional flow control - neither of which apply to datagrams.",
              "createdAt": "2022-01-25T00:26:25Z",
              "updatedAt": "2022-01-25T00:28:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zXA6m",
          "commit": {
            "abbreviatedOid": "5a21b43"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T00:48:06Z",
          "updatedAt": "2022-01-25T00:57:14Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I prefer the term initiated since that maps to what QUIC uses to refer to streams. If that's OK with you I'm going to declare this editorial and that we can discuss it with the WG instead of in the design team.",
              "createdAt": "2022-01-25T00:48:06Z",
              "updatedAt": "2022-01-25T00:57:14Z"
            },
            {
              "originalPosition": 52,
              "body": "Unfortunately that wouldn't be correct. The Quarter Stream ID is present in the \"QUIC DATAGRAM frame\" encoding of HTTP Datagrams, but not in the Capsule encoding. Both encodings contain the HTTP Datagram Payload field.",
              "createdAt": "2022-01-25T00:49:47Z",
              "updatedAt": "2022-01-25T00:57:14Z"
            },
            {
              "originalPosition": 91,
              "body": "I don't disagree, but since we're most likely to remove this appendix entirely before publication, I'd rather not spend too much time on it. I've added Example- in more places to make this clearer",
              "createdAt": "2022-01-25T00:52:05Z",
              "updatedAt": "2022-01-25T00:57:14Z"
            },
            {
              "originalPosition": 122,
              "body": "Agreed, done.",
              "createdAt": "2022-01-25T00:52:18Z",
              "updatedAt": "2022-01-25T00:57:14Z"
            },
            {
              "originalPosition": 119,
              "body": "Agreed, done.",
              "createdAt": "2022-01-25T00:53:57Z",
              "updatedAt": "2022-01-25T00:57:14Z"
            },
            {
              "originalPosition": 174,
              "body": "I've removed this subsection. We'll decide as a WG whether we want to tackle extension composition in this draft or not",
              "createdAt": "2022-01-25T00:56:38Z",
              "updatedAt": "2022-01-25T00:57:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zXC14",
          "commit": {
            "abbreviatedOid": "dff420c"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T01:03:31Z",
          "updatedAt": "2022-01-25T01:03:32Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "That being the case, please be consistent and use \"initiate\" rather than \"allocate\" later.  I was just trying to make the terms you use in the definition consistent with the usage later.  (In the direction I prefer, but you do get editor's privilege there.)",
              "createdAt": "2022-01-25T01:03:31Z",
              "updatedAt": "2022-01-25T01:03:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zXDD2",
          "commit": {
            "abbreviatedOid": "dff420c"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T01:05:07Z",
          "updatedAt": "2022-01-25T01:05:08Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Right.  I did say that maybe you can use words, which would be fine.  The problem here is that I don't quite know how this is expected to fit into the bigger picture without a drawing on a lot more context.  I have that context, but I fear that others will not.",
              "createdAt": "2022-01-25T01:05:07Z",
              "updatedAt": "2022-01-25T01:05:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zXF-K",
          "commit": {
            "abbreviatedOid": "dff420c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T01:27:56Z",
          "updatedAt": "2022-01-25T01:27:56Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Added some text to clarify that random allocations are allowed",
              "createdAt": "2022-01-25T01:27:56Z",
              "updatedAt": "2022-01-25T01:27:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zXF-Y",
          "commit": {
            "abbreviatedOid": "dff420c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T01:27:57Z",
          "updatedAt": "2022-01-25T01:27:57Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Fair enough, I've added some text right above the diagram.",
              "createdAt": "2022-01-25T01:27:57Z",
              "updatedAt": "2022-01-25T01:27:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zXF-7",
          "commit": {
            "abbreviatedOid": "dff420c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T01:28:01Z",
          "updatedAt": "2022-01-25T01:28:01Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Fair enough, you've convinced me. Switched to client-allocated.",
              "createdAt": "2022-01-25T01:28:01Z",
              "updatedAt": "2022-01-25T01:28:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zawyG",
          "commit": {
            "abbreviatedOid": "ad34710"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T17:45:50Z",
          "updatedAt": "2022-01-25T18:05:08Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I don't think this text around a context ID allocation service is doing much. Why not simply talk about the client and server as monolithic.",
              "createdAt": "2022-01-25T17:45:50Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nfield of HTTP Datagrams (see {{HTTP-DGRAM}}) has the format defined in {{dgram-format}}.\r\n```",
              "createdAt": "2022-01-25T17:47:56Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nContext ID field defined below directly follows the Quarter Stream ID field which is at\r\n```",
              "createdAt": "2022-01-25T17:48:15Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nthe start of the QUIC DATAGRAM frame payload:\r\n```",
              "createdAt": "2022-01-25T17:49:56Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            },
            {
              "originalPosition": 73,
              "body": "If you are going to have a 2119 SHALL that includes buffering something, you need to provide some guidance.",
              "createdAt": "2022-01-25T17:51:06Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nsemantics and format of a given context ID.\r\nThis document does not define how registration occurs, though some examples of\r\nhow it might occur are provided in {{example-extensions}}.\r\nDepending on the method being used, it is possible for datagrams to be received with\r\nContext IDs which have not yet been registered, for instance due to a race\r\ncondition in the arrival of the datagram and the registration.\r\n```",
              "createdAt": "2022-01-25T17:54:40Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            },
            {
              "originalPosition": 137,
              "body": "```suggestion\r\nbe able to consequently handle and parse datagrams with the context ID, while all\r\n```",
              "createdAt": "2022-01-25T17:55:36Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            },
            {
              "originalPosition": 139,
              "body": "I'm not sure what this text is saying. The client of course speaks first, so:\r\n\r\n1. I think you're saying that the client is registering it and the server just silently accepts. Is that really what one would want? No acknowledgement from the server?\r\n2. Can the server just unilaterally register?\r\n3. Is there a way for the client to say I want to send but not receive?\r\n\r\nI know this is an example, but people are going to imitate it.\r\n\r\n\r\n",
              "createdAt": "2022-01-25T17:59:40Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            },
            {
              "originalPosition": 171,
              "body": "Again, I see that this is an example, but I don't see how this works as a practical matter. What acknowledges this? How do I discover that the peer doesn't support this extension? Or does, for that matter? I can't just register a compressed CID and then wait to see if my  data goes through.\r\n\r\n",
              "createdAt": "2022-01-25T18:04:25Z",
              "updatedAt": "2022-01-25T18:05:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4za6ak",
          "commit": {
            "abbreviatedOid": "ad34710"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T18:20:26Z",
          "updatedAt": "2022-01-25T18:30:00Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I'm not sure what you're suggesting. Can you elaborate?",
              "createdAt": "2022-01-25T18:20:26Z",
              "updatedAt": "2022-01-25T18:30:00Z"
            },
            {
              "originalPosition": 73,
              "body": "What kind of guidance did you have in mind?",
              "createdAt": "2022-01-25T18:21:58Z",
              "updatedAt": "2022-01-25T18:30:00Z"
            },
            {
              "originalPosition": 139,
              "body": "1. I personally don't think there's value in an acknowledgement, but I think that's something we'll need to hash out with the WG when we discuss extension composability and registration\r\n2. In general, yes. Individual extensions can prohibit it though\r\n3. Not in this particular example, but an extension can absolutely do that\r\n\r\nAt a high level, this appendix is most likely not going to survive publication, let's see what it looks like once we've figured out registration and composability with the WG",
              "createdAt": "2022-01-25T18:25:47Z",
              "updatedAt": "2022-01-25T18:30:00Z"
            },
            {
              "originalPosition": 171,
              "body": "Added a sentence about needing a header",
              "createdAt": "2022-01-25T18:29:14Z",
              "updatedAt": "2022-01-25T18:30:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4za98C",
          "commit": {
            "abbreviatedOid": "8e7ca06"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T18:33:58Z",
          "updatedAt": "2022-01-25T18:33:58Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "I'm not really comfortable with that, because it means we'll just rediscover these points.\r\n\r\nIf we don't want to fix up this appendix, let's move it into a wiki or whatever.\r\n\r\n\r\n",
              "createdAt": "2022-01-25T18:33:58Z",
              "updatedAt": "2022-01-25T18:33:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4za9_0",
          "commit": {
            "abbreviatedOid": "8e7ca06"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T18:34:14Z",
          "updatedAt": "2022-01-25T18:34:14Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "1xRTT?",
              "createdAt": "2022-01-25T18:34:14Z",
              "updatedAt": "2022-01-25T18:34:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zbANy",
          "commit": {
            "abbreviatedOid": "8e7ca06"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T18:42:51Z",
          "updatedAt": "2022-01-25T18:42:52Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/79",
              "createdAt": "2022-01-25T18:42:52Z",
              "updatedAt": "2022-01-25T18:42:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zbDO8",
          "commit": {
            "abbreviatedOid": "8e7ca06"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T18:54:57Z",
          "updatedAt": "2022-01-25T18:54:57Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "I've added an explicit note stating that this appendix will be removed before WGLC",
              "createdAt": "2022-01-25T18:54:57Z",
              "updatedAt": "2022-01-25T18:54:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zbDre",
          "commit": {
            "abbreviatedOid": "a4a5e42"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T18:56:44Z",
          "updatedAt": "2022-01-25T18:56:44Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Added",
              "createdAt": "2022-01-25T18:56:44Z",
              "updatedAt": "2022-01-25T18:56:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zbEMo",
          "commit": {
            "abbreviatedOid": "a4a5e42"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T18:58:51Z",
          "updatedAt": "2022-01-25T18:58:51Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "This would not be my preference. If the point of the appendix is to help make this clearer, then having it be confusing does not achieve that.",
              "createdAt": "2022-01-25T18:58:51Z",
              "updatedAt": "2022-01-25T18:58:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zbTV7",
          "commit": {
            "abbreviatedOid": "7c5da34"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T19:53:02Z",
          "updatedAt": "2022-01-25T19:53:02Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Fair enough, I've added a paragraph that answers your three questions above",
              "createdAt": "2022-01-25T19:53:02Z",
              "updatedAt": "2022-01-25T19:53:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOETZKbc4zbar6",
          "commit": {
            "abbreviatedOid": "7c5da34"
          },
          "author": "achernya",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-25T20:24:45Z",
          "updatedAt": "2022-01-25T20:24:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOETZKbc4zb_yv",
          "commit": {
            "abbreviatedOid": "144847a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:24:52Z",
          "updatedAt": "2022-01-25T23:24:53Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Merged #79",
              "createdAt": "2022-01-25T23:24:53Z",
              "updatedAt": "2022-01-25T23:24:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOETZKbc4xk62n",
      "title": "Remove text about extension service.",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/pull/79",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-25T18:42:34Z",
      "updatedAt": "2022-01-25T23:22:43Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-connect-udp",
      "baseRefName": "2021_design_team_consensus",
      "baseRefOid": "8e7ca06371ff271399bde3c4d4dbb13b1e492b73",
      "headRepository": "ekr/draft-ietf-masque-connect-udp",
      "headRefName": "extension_service",
      "headRefOid": "5907c9c8691e551b00dc9856c9b433a44ea1c917",
      "closedAt": "2022-01-25T23:22:43Z",
      "mergedAt": "2022-01-25T23:22:43Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e4c49206685fc000ca4a6f158c5c740774b80a29"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you elaborate on what the motivation for this is? Introducing the \"context ID allocation service\" concept means that extensions can conveniently say \"Then request a context ID from the allocation service and doo foo with it\". If we remove this text, it'll make extension specs harder to write.",
          "createdAt": "2022-01-25T18:49:46Z",
          "updatedAt": "2022-01-25T18:49:46Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "Occam's Razor. It's unnecessary complication that makes this text harder to read. I don't agree. The job of the specification is to document external behavior.\r\n\r\nI don't agree that it makes future specs more difficult. They can just say \"allocate a context ID\". It's an internal detail of the implementation that there is a context ID allocation service. \r\n\r\n\r\n\r\n",
          "createdAt": "2022-01-25T18:53:04Z",
          "updatedAt": "2022-01-25T18:53:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "How about the following? It removes the concept but keeps the requirements we need.\r\n\r\n```\r\nContext IDs are 62-bit integers (0 to 2<sup>62</sup>-1). Context IDs are encoded\r\nas variable-length integers, see {{Section 16 of QUIC}}. The context ID value of\r\n0 is reserved for UDP payloads, while non-zero values are dynamically allocated:\r\nnon-zero even-numbered context IDs are client-allocated, and odd-numbered\r\ncontext IDs are server-allocated. Implementations are responsible for only allocating\r\neach context ID once, though they need not allocate them in order.  Once allocated, any\r\ncontext ID can be used by both client and server - only allocation carries\r\nseparate namespaces to avoid requiring synchronization. Additionally, note that\r\nthe context ID namespace is tied to a given HTTP request: it is possible for a\r\ncontext ID with the same numeric value to be simultaneously assigned different\r\nsemantics in distinct requests, potentially with different semantics.\r\n```",
          "createdAt": "2022-01-25T19:00:56Z",
          "updatedAt": "2022-01-25T19:00:56Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I prefer removing the allocation service as a concept and specifying the requirements.\r\n\r\nI did find this a bit confusing in David's proposed text\r\n\r\n>  - only allocation carries separate namespaces to avoid requiring synchronization\r\n\r\nI think the point is clear already and the rationale is not required.  Maybe remove this clause?",
          "createdAt": "2022-01-25T19:05:24Z",
          "updatedAt": "2022-01-25T19:05:24Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "This text still has the problem that it first says you can allocate each context ID once and then later it says actually you can allocate it once per namespace. Why not say this upfront as in my PR?",
          "createdAt": "2022-01-25T20:39:21Z",
          "updatedAt": "2022-01-25T20:39:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOETZKbc4zb-I1",
          "commit": {
            "abbreviatedOid": "7bbb616"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "My apologies @ekr I think I had missed the added sentence in the middle when looking at this the first time. This LGTM modulo removal of the optional sentence at the end.",
          "createdAt": "2022-01-25T23:12:59Z",
          "updatedAt": "2022-01-25T23:13:33Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I'd suggest leaving this Optional bit out for now\r\n```suggestion\r\n```",
              "createdAt": "2022-01-25T23:12:59Z",
              "updatedAt": "2022-01-25T23:13:33Z"
            }
          ]
        }
      ]
    }
  ]
}